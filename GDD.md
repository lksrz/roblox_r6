Zróbmy 4v4, rundowe “Steal & Secure”: drużyna Atak/Obrona, cel – ukraść “Rdzeń/Maszynkę do Muzy” (brainrot vibe) albo utrzymać go do końca rundy. Rozgrywka szybka, bez przemocy (piankowe blastery, farba), mało assetów 3D (klocki, tile-sety, UI + VFX). Pętla uzależniająca = ranki sezonowe + kolekcjonowalne “Gadżety Specjalne” (karteczki/skin-y) + krótkie wyzwania dzienne. MVP skupia się na 1 mapie modułowej, 3 rolach, 6 gadżetach, prostej ekonomii.

⸻

1) High-concept (R6 x Brainrot, kids-safe)
	•	Pitch: “Rainbow Siege: Steal the Beat” – taktyczne 4v4, przebijaj kartonowe ściany, skanuj, buduj barykady, ukradnij “BoomBox/Rdzeń” i dowieź go do strefy ekstrakcji.
	•	Ton: kolorowo, memicznie, zero przemocy (pianka, konfetti, slime).
	•	Czas rundy: 3 min. BO5 (pierwsze do 3). Zmiana stron co 2 rundy.
	•	TTK (time-to-tag): wysoki; gracze “oznaczani” farbą → krótkie KO (5s) zamiast śmierci.

⸻

2) MVP – zakres absolutny

Tryb: Steal & Secure (jedyny na start).
Zespoły: 4v4 (Matchmaking prosty MMR-lite).
Mapa: 1 mapa modułowa (4–6 pokojów z klocków), 2 warianty ułożenia na serwer start.
Role (3) – “mini-operatorzy”:
	1.	Breacher – piankowy “Ładunek Konfetti” (otwiera kartonowe ściany/drzwi).
	2.	Scout – skaner pingujący przez ściany (krótki “ping” co 20s).
	3.	Builder – barykady + piankowe tarcze (szybkie ustawianie coverów).
(Obrońcy wybierają 2 Builderów max; Atakujący min. 1 Breacher.)

Gadżety (6 szt. na start):
	•	Atak: Ładunek Konfetti, Mini-dron (zasięg mały), Dym konfetti (zasłona).
	•	Obrona: Barykada kartonowa, Alarm-gumka (pisk przy przejściu), Piankowa mina (odrzut).

Broń (piankowe):
	•	Pistolet, Karabinek, Strzelba piankowa, Specjal: “Bubble-Launcher” (krótkie root).
(Staty różnią się zasięgiem/spreadem; zero realistycznej przemocy.)

Cel rundy:
	•	Atak: ukraść Rdzeń z pokoju celu i dowieźć do strefy.
	•	Obrona: opóźniaj/odzyskuj. Odzysk = położyć Rdzeń z powrotem do pokoju lub utrzymać bez ekstrakcji.

Sterowanie/UX:
	•	Auto-pickup amunicji, aim assist lekki, duże przyciski UI.

⸻

3) Pętla motywacyjna (etycznie “lepka”)

Krótka pętla: mecz → punkty rangi + waluta miękka → paczka kosmetyków/gadżetów.
Średnia pętla: wyzwania dzienne/tygodniowe (3 proste cele, np. “2 ekstrakcje Rdzenia”).
Długa pętla: Ranga sezonowa (Bronze → Silver → Gold → Diamond – tylko wizual + lekki MMR).
Kolekcjonowanie: Karty Gadżetów (ramki, naklejki, trail farby); “Mastery” broni (poziomy 1–10).
Economy safety: bez “pay-to-win”: płatne tylko skiny, animacje, emblematy.

⸻

4) Ekonomia (prosta, przejrzysta)

Waluta	Pozyskanie	Wydanie	Balans
Tickets (soft)	mecze, wyzwania	paczki kosmetyczne, reskiny gadżetów	główny progres
Robux (hard)	zakup	przepustka mini, paczki kosmetyczne premium	wyłącznie kosmetyka

	•	Skrzynki bez RNG: zawsze pokazuj 3 możliwe dropy przed zakupem (“pick 1 of 3”).
	•	Battle-mini: ścieżka darmowa + premium (krótka, 10 poziomów).
	•	Sinks: reroll wyzwań, personalizacja profilu/rangi.

⸻

5) Rdzeń mechanik (jak w R6, ale lekko)
	•	Destrukcja “miękka”: tylko oznaczone ściany/okna (z klocków) → stan: pełna / dziura / wybita.
	•	Informacja i kontr-info: Scout ping, Alarmy u obrońców.
	•	Kontrola przestrzeni: Builder barykady i tarcze; Breacher odblokowuje ścieżki.
	•	Ekstrakcja Rdzenia: gdy niesiesz – widoczny “trail” (counterplay!), wolniejsze poruszanie.

⸻

6) Mapa i assety (low-asset pipeline)
	•	Tileset klocków: ściany, drzwi, okna, podłogi – 1 styl + 3 palety kolorów.
	•	Rekwizyt Rdzenia/Boomboxa: 1 styl, 3 skiny (common/rare/legend).
	•	Dekale + UI > modele: memiczne naklejki, bannery, VFX konfetti, outline’y.
	•	Modułowość: 6 pokojów (A–F) łączonych losowo: 2 generacje layoutu przy starcie serwera.
	•	Znaczniki zniszczeń: sprite’y/mesh-chunks zamiast złożonego fracture.

⸻

7) UX i dostępność (dzieci)
	•	Brak krwi/krzyku, dźwięki – śmieszne “plop”, “poof”.
	•	Czytelność: gruby outline drużyny, kolorowe ścieżki, waypointy.
	•	FTUE (onboarding 90s): interaktywne “naciśnij X by postawić barykadę”, “użyj skanera”.

⸻

8) Ranking i matchmaking
	•	MMR-lite: rating ukryty (Glicko-lite), rangi wizualne jawne.
	•	Dobór: waga wygrana>statystyki; priorytet ping/region.
	•	Anty-smurf: szybki awans przy wysokim WR na niskich rangach.

⸻

9) System progresji (szczegóły)

Rangi: Bronze (0–999), Silver (1000–1999), Gold (2000–2799), Diamond (2800+).
Mastery broni: XP za trafienia/ekstrakcje; progi 1–10 odblokowują naklejki i efekty wystrzału.
Gadżety: każdy ma 3 mody (np. Ładunek: szybciej/większa dziura/niższy hałas) – mody wyłącznie kosmetyczne lub QoL (np. inny efekt, NIE staty).

⸻

10) Live-ops (etyczne retencje)
	•	Daily Streak (max 7): Tickets + losowy sticker.
	•	Weekend Event: podwójne Tickets za ekstrakcje.
	•	Rotacja skinów: 2–3 itemy tygodniowo, jasno zapowiedziane (bez FOMO-paniki).

⸻

11) Technika (Roblox Studio / Luau)

Architektura:
	•	Serwer: logika rund, MMR-lite, zniszczenia, walka o Rdzeń.
	•	Klient: animacje, VFX, UI, predykcja ruchu.
	•	DataStoreService: rangi, inventory, streak. Backup + walidacja schematu.
	•	RemoteEvents/Functions: minimalny payload; walidacja anty-cheat (cooldowny po stronie serwera).
	•	Hit-reg: raycast serwerowy z potwierdzeniem klienta (anti-lag kompromis).
	•	Destrukcja: lista “breakable parts” z HP; zmiana na predefiniowane warianty mesh.
	•	Map loader: seed mapy → repeatowalny układ pokoi (łatwe A/B).

⸻

12) Analityka/KPI (mierzymy realnie)
	•	D1/D7/D30, Avg Match Length, Round Win Delta (atk/def), Carry% Rdzenia, Abandon%, Conversion (Robux), % dzieci w FTUE kończących tutorial.
	•	Eventy telemetryczne: destrukcja ścian, ping scouta, barykady użyte, dropy z paczek.

⸻

13) Anty-toxic & bezpieczeństwo
	•	Quick-chat predefiniowany (brawo, potrzebuję barykady, uwaga dron).
	•	Filtr czatu, mute all, szybki report (UI 1 klik).
	•	AFK-kick łagodny (ostrzeżenie → ghost spectator).

⸻

14) Roadmap rozwojowa (po MVP)
	1.	Nowa mapa modułowa #2 (temat szkoła/muzeum memów).
	2.	Nowa rola “Trickster” (fałszywe barykady / manekiny).
	3.	Tryb “Quick Heist 3v3” (1 runda, 90s, dla mobile).
	4.	Kluby (mini-clany): banery, odznaki, tablica wyników.
	5.	Tryb ranked (sezonowy): soft reset rangi, nagrody sezonowe (flary, skórki).

⸻

15) Produkcja – minimalny koszt assetów
	•	Modele 3D: 1 Rdzeń/Boombox, 3 bronie bazowe, 6 gadżetów low-poly.
	•	Tileset: 20–30 klocków (ściana/okno/drzwi/podłoga/schody).
	•	UI: 30 ikon (wektor), 10 stickerów start.
	•	VFX: konfetti, dym, ping, trail Rdzenia (materiały + particle).

⸻

16) Balans – parametry startowe (do testu)
	•	Runda: 180 s.
	•	Ekstrakcja: 6 s stania w strefie; drop przy KO.
	•	Ładunek Konfetti: 2 szt./rundę, czas podkładania 2 s, radius drzwi/okno.
	•	Scout Ping: co 20 s, 1.2 s opóźnienia, 1.5 s outline na wrogu.
	•	Barykada: 4 szt./gracz, HP: 2 trafienia strzelby / 5 karabinka.
	•	Bubble-Launcher: cooldown 15 s, root 1.2 s (nie działa przez ściany).
	•	Respawn: brak; odrodzenie 10 s tylko w “Quick Heist” (później).

⸻

17) Testy i ryzyka

Ryzyka:
	•	Zbyt trudna komunikacja taktyczna dla dzieci → quick-chat + pingi kontekstowe.
	•	Destrukcja zbyt kosztowna wydajnościowo → predefiniowane stany, mało rigidbody.
	•	“Pay-to-win” percepcja → twardo kosmetyczne monetyzacje.

Testy A/B (krótkie):
	•	TTK wysoki vs średni; ping 1.2 s vs 2.0 s; ładunek 2 vs 3.
	•	Mapa: korytarze wąskie vs średnie; liczba breakable na pokój.

⸻

18) Dlaczego to zadziała (mechanizm)
	•	Znany schemat R6 → jasne role i decyzje (wejść / skanować / wzmacniać).
	•	Brainrot – jasny, śmieszny cel kradzieży (mocny moment narracyjny przy ekstrakcji).
	•	Krótka runda + BO5 = “jeszcze jedna” (efekt slot-machine bez hazardu).
	•	Progres wizualny (rangi, mastery, naklejki) → naturalne cele kolekcjonerskie.
	•	Niski koszt contentu dzięki modularyzacji i UI-driven kosmetykom.

⸻

19) Rekomendacje (jasno)
	1.	Budujemy MVP dokładnie jak powyżej: 1 mapa modułowa, 3 role, 6 gadżetów, 3 bronie, 1 tryb.
	2.	Skupiamy się na pętli ranga + wyzwania dzienne + mastery (zero P2W).
Warunki stosowalności: target mobile + PC; zespół ma ograniczony pipeline 3D; cel – szybki retention test.

⸻

20) Następny krok (konkretny)
	•	Greybox mapy + prototyp gadżetów (ładunek, ping, barykada) i telemetria rundy.
	•	Test wewnętrzny: czy Atak/Obrona mają ~50/50 WR; czy ekstrakcja jest czytelna i ekscytująca.

----

Konkluzja

Budujemy całość “code-first” w Rojo: repo z czytelną strukturą src/, jedna mapa-modułowa, 3 role, 6 gadżetów, ekonomia + rangi w DataStore. Poniżej gotowy szkielet projektu, default.project.json, oraz moduły Luau (round, role, gadgety, destrukcja, broń, networking, MMR-lite). Wrzucasz do repo, rojo serve i jedziesz.

⸻

1) Struktura repo (Rojo)

roblox-r6-brainrot/
├─ default.project.json
├─ README.md
├─ .gitignore
├─ src/
│  ├─ ReplicatedStorage/
│  │  ├─ Shared/
│  │  │  ├─ Types.lua
│  │  │  ├─ Config.lua
│  │  │  └─ Signals.lua
│  │  ├─ Net/
│  │  │  ├─ Events.lua
│  │  │  └─ Remotes.rbxm        (generowane ze skryptu lub ręcznie)
│  │  ├─ Systems/
│  │  │  ├─ Loadouts.lua
│  │  │  ├─ Gadgets/
│  │  │  │  ├─ GadgetBase.lua
│  │  │  │  ├─ ConfettiCharge.lua
│  │  │  │  ├─ ScoutPing.lua
│  │  │  │  ├─ Barricade.lua
│  │  │  │  ├─ AlarmGum.lua
│  │  │  │  └─ FoamMine.lua
│  │  │  └─ Weapons/
│  │  │     ├─ WeaponBase.lua
│  │  │     ├─ Pistol.lua
│  │  │     ├─ Carbine.lua
│  │  │     └─ Shotgun.lua
│  │  └─ MapGen/
│  │     ├─ Rooms.lua
│  │     └─ LayoutGen.lua
│  ├─ ServerScriptService/
│  │  ├─ Main.server.lua
│  │  ├─ Round/
│  │  │  ├─ RoundState.lua
│  │  │  ├─ RoundService.lua
│  │  │  └─ TeamBalance.lua
│  │  ├─ Gameplay/
│  │  │  ├─ ObjectiveService.lua
│  │  │  ├─ DestructionService.lua
│  │  │  └─ HitRegService.lua
│  │  ├─ Progression/
│  │  │  ├─ ProfileStore.lua
│  │  │  ├─ RankMMR.lua
│  │  │  └─ Challenges.lua
│  │  └─ AntiCheat/
│  │     └─ RateLimiter.lua
│  ├─ StarterPlayer/
│  │  └─ StarterPlayerScripts/
│  │     ├─ UI/
│  │     │  ├─ Hud.client.lua
│  │     │  └─ Menu.client.lua
│  │     ├─ Input/
│  │     │  └─ InputController.client.lua
│  │     └─ ClientControllers/
│  │        ├─ CameraController.client.lua
│  │        └─ Effects.client.lua
│  ├─ StarterGui/
│  │  └─ Screens/
│  │     ├─ LobbyScreen.rbxm     (UI minimalne)
│  │     └─ EndScreen.rbxm
│  └─ ServerStorage/
│     └─ Prefabs/
│        ├─ Breakables.rbxm      (prefaby ścian/drzwi/okien z tagami)
│        └─ ObjectiveBoombox.rbxm

default.project.json

{
  "name": "Rainbow-Siege-Brainrot",
  "tree": {
    "$className": "DataModel",
    "ReplicatedStorage": {
      "$path": "src/ReplicatedStorage"
    },
    "ServerScriptService": {
      "$path": "src/ServerScriptService"
    },
    "StarterPlayer": {
      "$className": "StarterPlayer",
      "StarterPlayerScripts": {
        "$path": "src/StarterPlayer/StarterPlayerScripts"
      }
    },
    "StarterGui": {
      "$path": "src/StarterGui"
    },
    "ServerStorage": {
      "$path": "src/ServerStorage"
    }
  }
}

Uruchomienie:
	•	rojo serve → Studio: Plugins → Rojo → Connect.
	•	Commit/branch: feature flags w Shared/Config.lua (np. AB_TEST = "TTK_MED").

⸻

2) Kluczowe moduły (Luau) – MVP

ReplicatedStorage/Shared/Config.lua

local Config = {
    ROUND = { LENGTH_SEC = 180, WIN_TARGET = 3, SWITCH_SIDES_EVERY = 2 },
    OBJ = { EXTRACT_TIME = 6, CARRIER_SLOW = 0.8 },
    NET = { RATE_HZ = 15 },
    BALANCE = { TEAM_SIZE = 4 },
    GADGETS = {
        ConfettiCharge = { PLACE_TIME = 2.0, CHARGES = 2 },
        ScoutPing      = { COOLDOWN = 20.0, REVEAL = 1.5 },
        Barricade      = { MAX_PER_PLAYER = 4, HP = 200 },
        AlarmGum       = { RANGE = 10, COOLDOWN = 10 },
        FoamMine       = { KNOCKBACK = 40, ARMED_DELAY = 1.0 }
    },
    WEAPONS = {
        Pistol  = { RPM = 300, DAMAGE = 12, SPREAD = 2.5 },
        Carbine = { RPM = 450, DAMAGE = 10, SPREAD = 3.5 },
        Shotgun = { RPM = 80,  DAMAGE = 8,  PELLETS = 8, SPREAD = 8.0 }
    }
}
return Config

Networking – jedno źródło prawdy

ReplicatedStorage/Net/Events.lua

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Events = {}

local function ensure(name, class)
    local folder = ReplicatedStorage:FindFirstChild("Remotes") or Instance.new("Folder")
    folder.Name = "Remotes"; folder.Parent = ReplicatedStorage
    local obj = folder:FindFirstChild(name)
    if not obj then obj = Instance.new(class); obj.Name = name; obj.Parent = folder end
    return obj
end

Events.RoundChanged   = ensure("RoundChanged", "RemoteEvent")
Events.RequestSpawn   = ensure("RequestSpawn", "RemoteFunction")
Events.UseGadget      = ensure("UseGadget", "RemoteEvent")
Events.FireWeapon     = ensure("FireWeapon", "RemoteEvent")
Events.HitConfirm     = ensure("HitConfirm", "RemoteEvent")
Events.Objective      = ensure("ObjectiveEvent", "RemoteEvent")

return Events

Round loop (serwer)

ServerScriptService/Round/RoundState.lua

export type State = "Lobby" | "Prep" | "Live" | "End"
local State = { Lobby="Lobby", Prep="Prep", Live="Live", End="End" }
return State

ServerScriptService/Round/RoundService.lua

local Players = game:GetService("Players")
local Teams = game:GetService("Teams")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Config = require(ReplicatedStorage.Shared.Config)
local Events = require(ReplicatedStorage.Net.Events)
local TeamBalance = require(script.Parent.TeamBalance)

local RoundService = {}
local scores = { Attack = 0, Defense = 0 }
local state = "Lobby"
local roundId = 0

local function broadcast()
    Events.RoundChanged:FireAllClients({
        state = state, scores = scores, roundId = roundId
    })
end

function RoundService.StartMatch()
    TeamBalance.AutoAssign()
    scores.Attack, scores.Defense = 0, 0
    roundId += 1

    while scores.Attack < Config.ROUND.WIN_TARGET and scores.Defense < Config.ROUND.WIN_TARGET do
        state = "Prep"; broadcast()
        task.wait(8)

        state = "Live"; broadcast()
        local winner = RoundService.PlayRound(roundId)
        scores[winner] += 1; state = "End"; broadcast()
        task.wait(6)

        local total = scores.Attack + scores.Defense
        if total % Config.ROUND.SWITCH_SIDES_EVERY == 0 then
            TeamBalance.SwitchSides()
        end
    end
    -- TODO: season rewards hook
end

function RoundService.PlayRound(rid)
    local ObjectiveService = require(game.ServerScriptService.Gameplay.ObjectiveService)
    ObjectiveService.SpawnObjective()
    local t0 = os.clock()

    while os.clock() - t0 < Config.ROUND.LENGTH_SEC do
        local status = ObjectiveService.Tick()
        if status == "AttackWin" then return "Attack" end
        if status == "DefenseWin" then return "Defense" end
        task.wait(0.25)
    end
    return "Defense" -- time out ⇒ obrońcy
end

return RoundService

ServerScriptService/Round/TeamBalance.lua

local Teams = game:GetService("Teams")
local Players = game:GetService("Players")

local TeamBalance = {}
local ATTACK_NAME, DEFENSE_NAME = "Attack", "Defense"

local function getTeam(name)
    local t = Teams:FindFirstChild(name)
    if not t then t = Instance.new("Team"); t.Name = name; t.Parent = Teams end
    return t
end

function TeamBalance.AutoAssign()
    local atk, def = getTeam(ATTACK_NAME), getTeam(DEFENSE_NAME)
    local i = 0
    for _,plr in ipairs(Players:GetPlayers()) do
        plr.Team = (i % 2 == 0) and atk or def
        i += 1
    end
end

function TeamBalance.SwitchSides()
    for _,plr in ipairs(Players:GetPlayers()) do
        plr.Team = (plr.Team and plr.Team.Name == ATTACK_NAME) and getTeam(DEFENSE_NAME) or getTeam(ATTACK_NAME)
    end
end

return TeamBalance

Cel gry (obiekt + ekstrakcja)

ServerScriptService/Gameplay/ObjectiveService.lua

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Teams = game:GetService("Teams")

local Config = require(ReplicatedStorage.Shared.Config)
local Events = require(ReplicatedStorage.Net.Events)

local ObjectiveService = {}
local objectiveModel, carrier, extractZone

function ObjectiveService.SpawnObjective()
    if objectiveModel then objectiveModel:Destroy() end
    objectiveModel = ServerStorage.Prefabs.ObjectiveBoombox:Clone()
    objectiveModel.Parent = workspace

    extractZone = workspace:FindFirstChild("ExtractZone") or Instance.new("Part")
    extractZone.Name = "ExtractZone"; extractZone.Anchored = true; extractZone.CanCollide=false
    extractZone.Size = Vector3.new(10,1,10); extractZone.Position = Vector3.new(0,0.5,80)
    extractZone.Parent = workspace
end

function ObjectiveService.Tick()
    if carrier then
        -- Trail + spowolnienie jest po stronie klienta; tu tylko logika serwerowa czasu
        if (carrier.Character and carrier.Character:FindFirstChild("HumanoidRootPart")) then
            local hrp = carrier.Character.HumanoidRootPart
            if (hrp.Position - extractZone.Position).Magnitude < 8 then
                -- ekstrakcja kanałem eventu (dla UI + nagród)
                Events.Objective:FireAllClients({ type="Extracted", by = carrier.UserId })
                return "AttackWin"
            end
        else
            carrier = nil -- drop po KO
        end
    end
    return nil
end

-- pickup/drop (wywoływane z HitReg/KO lub klienta przez Remote)
Events.Objective.OnServerEvent:Connect(function(plr, payload)
    if payload.type == "Pickup" and not carrier then
        carrier = plr; Events.Objective:FireAllClients({ type="Carry", by=plr.UserId })
    elseif payload.type == "Drop" and carrier == plr then
        carrier = nil; Events.Objective:FireAllClients({ type="Dropped", by=plr.UserId })
    end
end)

return ObjectiveService

Destrukcja “miękka” (tagi Breakable)

ServerScriptService/Gameplay/DestructionService.lua

local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Config = require(ReplicatedStorage.Shared.Config)

local DestructionService = {}
local hp = {} -- [instance] = currentHP

local function setState(part, state)
    -- predefiniowane warianty: "Full","Hole","Broken" jako dziecko Modelu
    for _,child in ipairs(part.Parent:GetChildren()) do
        if child:IsA("BasePart") then child.Transparency = 1 end
        if child.Name == state then
            for _,p in ipairs(child:GetChildren()) do
                if p:IsA("BasePart") then p.Transparency = 0 end
            end
        end
    end
end

function DestructionService.ApplyDamage(part, amount)
    if not CollectionService:HasTag(part, "Breakable") then return end
    hp[part] = (hp[part] or 200) - amount
    if hp[part] <= 0 then
        setState(part, "Broken")
    elseif hp[part] <= 100 then
        setState(part, "Hole")
    end
end

return DestructionService

Hit-reg i anty-spam

ServerScriptService/Gameplay/HitRegService.lua

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Config = require(ReplicatedStorage.Shared.Config)
local Events = require(ReplicatedStorage.Net.Events)
local DestructionService = require(script.Parent.DestructionService)
local RateLimiter = require(game.ServerScriptService.AntiCheat.RateLimiter)

Events.FireWeapon.OnServerEvent:Connect(function(plr, payload)
    if not RateLimiter.Allow(plr, "FireWeapon", 60) then return end -- 60 req/min
    -- payload: {origin, dir, weaponName}
    -- prosty raycast; kolizje z Breakable ⇒ zadaj dmg ścianie
    local origin = payload.origin; local dir = payload.dir
    local result = workspace:Raycast(origin, dir)
    if result then
        local hit = result.Instance
        DestructionService.ApplyDamage(hit, 25)
        Events.HitConfirm:FireClient(plr, { ok = true })
    end
end)

ServerScriptService/AntiCheat/RateLimiter.lua

local RateLimiter = {}
local buckets = {} -- [userId][key] = {count, t0}

function RateLimiter.Allow(player, key, perMinute)
    local now = os.clock()
    local u = player.UserId
    buckets[u] = buckets[u] or {}
    local b = buckets[u][key]
    if not b or now - b.t0 > 60 then b = {count=0, t0=now}; buckets[u][key]=b end
    if b.count >= perMinute then return false end
    b.count += 1
    return true
end

return RateLimiter

Abstrakcje broni/gadżetów (re-używalne)

ReplicatedStorage/Systems/Weapons/WeaponBase.lua

local Config = require(game.ReplicatedStorage.Shared.Config)
local Events = require(game.ReplicatedStorage.Net.Events)

local WeaponBase = {}
WeaponBase.__index = WeaponBase

function WeaponBase.new(name, stats)
    local self = setmetatable({}, WeaponBase)
    self.Name = name; self.Stats = stats
    self._last = 0
    return self
end

function WeaponBase:TryFire(origin, dir)
    local now = os.clock()
    local rpm = self.Stats.RPM or 300
    local delay = 60 / rpm
    if now - self._last < delay then return end
    self._last = now
    Events.FireWeapon:FireServer({ origin = origin, dir = dir, weaponName = self.Name })
end

return WeaponBase

ReplicatedStorage/Systems/Gadgets/GadgetBase.lua

local GadgetBase = {}
GadgetBase.__index = GadgetBase

function GadgetBase.new(name, charges, cooldown)
    local self = setmetatable({}, GadgetBase)
    self.Name = name; self.Charges = charges or 1; self.Cooldown = cooldown or 10
    self._readyAt = 0
    return self
end

function GadgetBase:CanUse()
    return self.Charges > 0 and os.clock() >= self._readyAt
end

function GadgetBase:Consume()
    self.Charges -= 1; self._readyAt = os.clock() + self.Cooldown
end

return GadgetBase

Przykładowy gadżet:
ReplicatedStorage/Systems/Gadgets/ScoutPing.lua

local GadgetBase = require(script.Parent.GadgetBase)
local Config = require(game.ReplicatedStorage.Shared.Config)
local Events = require(game.ReplicatedStorage.Net.Events)

local G = {}
G.__index = G
setmetatable(G, { __index = GadgetBase })

function G.new()
    local self = GadgetBase.new("ScoutPing", math.huge, Config.GADGETS.ScoutPing.COOLDOWN)
    return setmetatable(self, G)
end

function G:Use()
    if not self:CanUse() then return end
    self:Consume()
    Events.UseGadget:FireServer({ type = "ScoutPing" })
end

return G

Serwerowy handler pingu (w ServerScriptService/Main.server.lua):

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Teams = game:GetService("Teams")

local Config = require(ReplicatedStorage.Shared.Config)
local Events = require(ReplicatedStorage.Net.Events)

Events.UseGadget.OnServerEvent:Connect(function(plr, payload)
    if payload.type == "ScoutPing" then
        -- prosty “outline”: wyślij listę wrogów do drużyny plr
        local enemyTeamName = (plr.Team and plr.Team.Name == "Attack") and "Defense" or "Attack"
        local enemyTeam = Teams:FindFirstChild(enemyTeamName)
        local enemies = {}
        for _,p in ipairs(game.Players:GetPlayers()) do
            if p.Team == enemyTeam and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(enemies, p.Character.HumanoidRootPart.Position)
            end
        end
        for _,ally in ipairs(Players:GetPlayers()) do
            if ally.Team == plr.Team then
                Events.UseGadget:FireClient(ally, { type="ScoutPingReveal", pos=enemies, revealSec=Config.GADGETS.ScoutPing.REVEAL })
            end
        end
    end
end)

Proste MMR + rangi (server)

ServerScriptService/Progression/RankMMR.lua

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ProfileStore = require(script.Parent.ProfileStore)

local RankMMR = {}
-- Glicko-lite: stały K, wynik binarny
local K = 24

function RankMMR.Adjust(userId, won)
    local profile = ProfileStore.Get(userId)
    profile.mmr = profile.mmr or 1200
    profile.mmr += won and K or -K
    profile.mmr = math.max(600, math.min(3000, profile.mmr))
    ProfileStore.Set(userId, profile)
    return profile.mmr
end

function RankMMR.GetRank(mmr)
    if mmr < 1000 then return "Bronze"
    elseif mmr < 2000 then return "Silver"
    elseif mmr < 2800 then return "Gold"
    else return "Diamond" end
end

return RankMMR

ServerScriptService/Progression/ProfileStore.lua

local DataStoreService = game:GetService("DataStoreService")
local store = DataStoreService:GetDataStore("RSB_Profiles_v1")

local ProfileStore = {}

function ProfileStore.Get(userId)
    local data = nil
    pcall(function() data = store:GetAsync(tostring(userId)) end)
    return data or { mmr = 1200, tickets = 0, mastery = {} }
end

function ProfileStore.Set(userId, tbl)
    pcall(function() store:SetAsync(tostring(userId), tbl) end)
end

return ProfileStore


⸻

3) Minimalny klient (HUD + input)

StarterPlayer/StarterPlayerScripts/Input/InputController.client.lua

local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Events = require(ReplicatedStorage.Net.Events)

local Input = {}
local firing = false

UserInputService.InputBegan:Connect(function(io, gpe)
    if gpe then return end
    if io.UserInputType == Enum.UserInputType.MouseButton1 then
        firing = true
    end
end)
UserInputService.InputEnded:Connect(function(io)
    if io.UserInputType == Enum.UserInputType.MouseButton1 then
        firing = false
    end
end)

game:GetService("RunService").RenderStepped:Connect(function(dt)
    if not firing then return end
    local cam = workspace.CurrentCamera
    local origin = cam.CFrame.Position
    local dir = cam.CFrame.LookVector * 500
    Events.FireWeapon:FireServer({ origin = origin, dir = dir, weaponName = "Carbine" })
end)

StarterPlayer/StarterPlayerScripts/UI/Hud.client.lua

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Events = require(ReplicatedStorage.Net.Events)

Events.RoundChanged.OnClientEvent:Connect(function(payload)
    -- TODO: odświeżenie timera, wyników
end)

Events.UseGadget.OnClientEvent:Connect(function(payload)
    if payload.type == "ScoutPingReveal" then
        -- narysuj markery na payload.pos przez payload.revealSec
    end
end)


⸻

4) MapGen (modułowa 1 mapa, bez artu)

ReplicatedStorage/MapGen/Rooms.lua

return {
    A = { exits = {"B","C"} },
    B = { exits = {"A","D"} },
    C = { exits = {"A","D"} },
    D = { exits = {"B","C","E"} },
    E = { exits = {"D","F"} },
    F = { exits = {"E"} }
}

ReplicatedStorage/MapGen/LayoutGen.lua

local Rooms = require(script.Parent.Rooms)
local LayoutGen = {}

function LayoutGen.Generate(seed)
    math.randomseed(seed or os.time())
    -- wybierz 5-6 pokoi i ustaw ich pozycje w siatce 3x3
    local picked = {"A","B","C","D","E","F"}
    -- TODO: spawn prefaby Breakables.rbxm i ExtractZone
    return picked
end

return LayoutGen


⸻

5) Pipeline dev (krótko)
	•	Instalacja: Rojo (CLI), Studio plugin.
	•	Run lokalnie: rojo serve → test w Play Solo.
	•	Feature flags: w Shared/Config.lua.
	•	Breakables: prefabry w ServerStorage/Prefabs/Breakables.rbxm z tagiem Breakable i wariantami Full/Hole/Broken.
	•	Objective: ObjectiveBoombox.rbxm (1 mesh low-poly).
	•	Analityka (opcjonalnie): prosty HTTPService → endpoint (dołącz później).

⸻

6) Checklista MVP (spełnia/nie spełnia)
	•	MapGen 1 mapa modułowa – spełnia (LayoutGen stub).
	•	3 role, 6 gadżetów – częściowo (stub, 3 gotowce).
	•	3 bronie – spełnia (parametry w Config, bazowa mechanika).
	•	Tryb Steal & Secure – spełnia (ObjectiveService).
	•	Rangi/MMR – spełnia (RankMMR + ProfileStore).
	•	Ekonomia (Tickets) – minimal (field w profilu; sklep później).
	•	Anti-cheat rate-limit – spełnia (RateLimiter).

⸻

7) Rekomendacje (2 opcje)
	1.	Start “vanilla” (bez zewn. bibliotek) – 100% kontrola, mniejszy narzut; idealne na MVP.
	2.	Dodać po MVP: Wally + lekkie pakiety (np. sygnały, tabele), jeżeli wzrośnie złożoność.

Trade-off: biblioteki przyspieszą później, ale komplikują setup na starcie.

⸻

8) Następne kroki 
	•	Uzupełnić gadżety: ConfettiCharge, Barricade, FoamMine (serwerowe efekty + VFX po stronie klienta).
	•	Dodać KO 5s zamiast śmierci w HitRegService (downed state).
	•	Podpiąć UI timera/scores w Hud.client.lua.
	•	Dołożyć trail i spowolnienie dla carrier’a (klient).
	•	A/B: Config.ROUND.LENGTH_SEC 150 vs 180; ScoutPing.REVEAL 1.2 vs 1.5.

