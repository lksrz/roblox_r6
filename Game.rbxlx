<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">ClientScripts</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">Construction</string>
      </Properties>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">Generator</string>
          <string name="Source"><![CDATA[-- Construction.Generator: Procedural building generator (rooms, corridors, walls, doors, windows)
-- Single-responsibility: generate a building Model from config
-- No network, no input; pure generation using axis-aligned rectangles and part emission

local Workspace = game:GetService("Workspace")

local Generator = {}

export type Rect = { x0: number, z0: number, x1: number, z1: number }
export type Edge = { axis: "x" | "z", pos: number, s: number, e: number }

local function rectWidth(r: Rect) return math.abs(r.x1 - r.x0) end
local function rectLength(r: Rect) return math.abs(r.z1 - r.z0) end
local function rectCenter(r: Rect) return (r.x0 + r.x1) * 0.5, (r.z0 + r.z1) * 0.5 end
local function rectClone(r: Rect): Rect return { x0 = r.x0, z0 = r.z0, x1 = r.x1, z1 = r.z1 } end
local function makeRect(x0, z0, x1, z1): Rect return { x0 = x0, z0 = z0, x1 = x1, z1 = z1 } end

local function clamp(v, a, b)
    if v < a then return a end
    if v > b then return b end
    return v
end

-- Build BSP of footprint to rooms. Along splits we add corridor rects that connect children.
local function bspPartition(rng: Random, rect: Rect, cfg)
    local nodes = {}
    local corridors: { Rect } = {}

    local minW = cfg.Room.MinSize.Width
    local minL = cfg.Room.MinSize.Length
    local maxW = cfg.Room.MaxSize.Width
    local maxL = cfg.Room.MaxSize.Length
    local cw = cfg.CorridorWidth

    local function splitRec(r: Rect, depth: number)
        local w, l = rectWidth(r), rectLength(r)
        local canSplitW = w > maxW
        local canSplitL = l > maxL
        if (not canSplitW and not canSplitL) or depth > 50 then
            table.insert(nodes, r)
            return
        end

        local splitAlongX
        if canSplitW and canSplitL then
            splitAlongX = (w > l) -- bias towards the longer axis
        else
            splitAlongX = canSplitW
        end

        if splitAlongX then
            -- split along X: vertical cut parallel to Z, at x = k
            local minK = r.x0 + minW
            local maxK = r.x1 - minW
            if maxK - minK < minW then
                -- cannot split safely, accept as leaf
                table.insert(nodes, r)
                return
            end
            local k = rng:NextNumber(minK, maxK)
            -- clamp to avoid super small rooms
            k = clamp(k, r.x0 + minW, r.x1 - minW)
            local left = makeRect(r.x0, r.z0, k, r.z1)
            local right = makeRect(k, r.z0, r.x1, r.z1)

            -- add two corridor bands hugging the split so both adjacent rooms share an edge at x=k
            local leftBand = makeRect(k - cw * 0.5, r.z0, k, r.z1)
            local rightBand = makeRect(k, r.z0, k + cw * 0.5, r.z1)
            table.insert(corridors, leftBand)
            table.insert(corridors, rightBand)

            splitRec(left, depth + 1)
            splitRec(right, depth + 1)
        else
            -- split along Z: horizontal cut parallel to X, at z = k
            local minK = r.z0 + minL
            local maxK = r.z1 - minL
            if maxK - minK < minL then
                table.insert(nodes, r)
                return
            end
            local k = rng:NextNumber(minK, maxK)
            k = clamp(k, r.z0 + minL, r.z1 - minL)
            local bottom = makeRect(r.x0, r.z0, r.x1, k)
            local top = makeRect(r.x0, k, r.x1, r.z1)

            -- add two corridor bands hugging the split so both adjacent rooms share an edge at z=k
            local lowerBand = makeRect(r.x0, k - cw * 0.5, r.x1, k)
            local upperBand = makeRect(r.x0, k, r.x1, k + cw * 0.5)
            table.insert(corridors, lowerBand)
            table.insert(corridors, upperBand)

            splitRec(bottom, depth + 1)
            splitRec(top, depth + 1)
        end
    end

    splitRec(rect, 0)
    return nodes, corridors
end

-- Utilities to detect shared borders between a room and corridor to place doors
local function overlap1D(a0, a1, b0, b1)
    local s = math.max(a0, b0)
    local e = math.min(a1, b1)
    return s, e, (e > s)
end

local function sharedEdge(a: Rect, b: Rect): Edge?
    -- Check if they touch along a full edge with positive overlap in the other axis
    -- Left/right edges (x constant)
    if math.abs(a.x1 - b.x0) < 1e-3 or math.abs(b.x1 - a.x0) < 1e-3 then
        local x = math.abs(a.x1 - b.x0) < 1e-3 and a.x1 or b.x1
        local s, e, ok = overlap1D(a.z0, a.z1, b.z0, b.z1)
        if ok then return { axis = "z", pos = x, s = s, e = e } end
    end
    -- Top/bottom edges (z constant)
    if math.abs(a.z1 - b.z0) < 1e-3 or math.abs(b.z1 - a.z0) < 1e-3 then
        local z = math.abs(a.z1 - b.z0) < 1e-3 and a.z1 or b.z1
        local s, e, ok = overlap1D(a.x0, a.x1, b.x0, b.x1)
        if ok then return { axis = "x", pos = z, s = s, e = e } end
    end
    return nil
end

-- Lay out door openings on edges between rooms and corridors
local function planDoors(rng: Random, rooms: {Rect}, corridors: {Rect}, cfg)
    local doors = {} :: { [string]: { center: number, width: number } }
    local width = math.max(cfg.Door.Width or 6, (cfg.Door.MinWidth or 0))
    local maxPerRoom = 1
    local function edgeKey(edge: Edge)
        local function r(v) return string.format("%.2f", v) end
        return table.concat({ edge.axis, r(edge.pos), r(edge.s), r(edge.e) }, ":")
    end

    for _, room in ipairs(rooms) do
        local candidates = {}
        for _, hall in ipairs(corridors) do
            local edge = sharedEdge(room, hall)
            if edge then table.insert(candidates, edge) end
        end
        -- Shuffle candidates
        for i = #candidates, 2, -1 do
            local j = rng:NextInteger(1, i)
            candidates[i], candidates[j] = candidates[j], candidates[i]
        end
        local count = 0
        for _, edge in ipairs(candidates) do
            local margin = width * 0.5
            local s = edge.s + margin
            local e = edge.e - margin
            if e > s then
                local center = rng:NextNumber(s, e)
                doors[edgeKey(edge)] = { center = center, width = width }
                count = count + 1
                if count >= maxPerRoom then break end
            end
        end
        -- Fallback: guarantee at least one doorway per room
        if count == 0 and #candidates > 0 then
            -- pick the longest shared edge and place a centered door, clamped to edge length
            local best, bestLen
            for _, edge in ipairs(candidates) do
                local len = edge.e - edge.s
                if (not best) or (len > bestLen) then best, bestLen = edge, len end
            end
            if best and bestLen and bestLen > 0.5 then
                local desired = math.min(width, bestLen - 0.2)
                local center = (best.s + best.e) * 0.5
                doors[edgeKey(best)] = { center = center, width = math.max(2, desired) }
            end
        end
    end
    return doors
end

-- Select exterior doors on the outer footprint; also add short entrance corridors
local function planExteriorDoorsAndEntrances(rng: Random, footprint: Rect, corridors: {Rect}, cfg)
    local planned = {}
    local cnt = math.max(0, cfg.ExteriorDoors or 0)
    if cnt == 0 then return planned, corridors end

    local margin = cfg.Window.InsetFromCorner or 4
    local doorW = cfg.Door.Width
    local cw = cfg.CorridorWidth

    local choices = {
        { axis = "x", pos = footprint.z0, s = footprint.x0 + margin, e = footprint.x1 - margin }, -- south edge
        { axis = "x", pos = footprint.z1, s = footprint.x0 + margin, e = footprint.x1 - margin }, -- north edge
        { axis = "z", pos = footprint.x0, s = footprint.z0 + margin, e = footprint.z1 - margin }, -- west edge
        { axis = "z", pos = footprint.x1, s = footprint.z0 + margin, e = footprint.z1 - margin }, -- east edge
    }

    -- Pick edges and place doors
    for i = 1, cnt do
        local edge = choices[rng:NextInteger(1, #choices)]
        local span = edge.e - edge.s
        if span <= doorW * 1.5 then break end
        local center = rng:NextNumber(edge.s + doorW, edge.e - doorW)
        table.insert(planned, { axis = edge.axis, pos = edge.pos, center = center, width = doorW })

        -- Add entrance corridor spanning across the building …
        if edge.axis == "x" then
            -- north/south wall: primary corridor goes along Z across the footprint
            local x0 = center - cw * 0.5
            local x1 = center + cw * 0.5
            table.insert(corridors, makeRect(x0, footprint.z0, x1, footprint.z1))
            -- plus a perpendicular cross corridor across X at mid Z to guarantee intersections
            local zMid = (footprint.z0 + footprint.z1) * 0.5
            local z0 = zMid - cw * 0.5
            local z1 = zMid + cw * 0.5
            table.insert(corridors, makeRect(footprint.x0, z0, footprint.x1, z1))
        else
            -- east/west wall: primary corridor goes along X across the footprint
            local z0 = center - cw * 0.5
            local z1 = center + cw * 0.5
            table.insert(corridors, makeRect(footprint.x0, z0, footprint.x1, z1))
            -- plus a perpendicular cross corridor across Z at mid X to guarantee intersections
            local xMid = (footprint.x0 + footprint.x1) * 0.5
            local x0 = xMid - cw * 0.5
            local x1 = xMid + cw * 0.5
            table.insert(corridors, makeRect(x0, footprint.z0, x1, footprint.z1))
        end
    end

    return planned, corridors
end

-- Segment math: subtract intervals from [s,e] and return kept segments
local function subtractIntervals(s: number, e: number, openings: { {s: number, e: number} })
    table.sort(openings, function(a, b) return a.s < b.s end)
    local cursor = s
    local kept = {}
    for _, o in ipairs(openings) do
        local os = clamp(o.s, s, e)
        local oe = clamp(o.e, s, e)
        if oe > os and os > cursor then
            table.insert(kept, { s = cursor, e = os })
        end
        cursor = math.max(cursor, oe)
    end
    if cursor < e then
        table.insert(kept, { s = cursor, e = e })
    end
    return kept
end

-- Emit a set of wall parts along a straight edge with vertical bands to produce holes for doors/windows
local function emitWallBandParts(container: Instance, color: Color3, edge: Edge, bandY0: number, bandY1: number, openings, thickness: number, material: Enum.Material?)
    if bandY1 <= bandY0 then return end
    local segs = (#openings > 0) and subtractIntervals(edge.s, edge.e, openings) or { { s = edge.s, e = edge.e } }
    -- Small seam padding so adjacent segments from separate edges overlap slightly
    local seamPad = 0.2
    for _, seg in ipairs(segs) do
        local s = seg.s - seamPad
        local e = seg.e + seamPad
        local mid = (s + e) * 0.5
        local len = e - s
        if len > 0.05 then
            local part = Instance.new("Part")
            part.Anchored = true
            part.CanCollide = true
            part.TopSurface = Enum.SurfaceType.Smooth
            part.BottomSurface = Enum.SurfaceType.Smooth
            part.Color = color
            if material then part.Material = material end
            local height = bandY1 - bandY0
            if edge.axis == "x" then
                part.Size = Vector3.new(len, height, thickness)
                part.CFrame = CFrame.new(mid, bandY0 + height * 0.5, edge.pos)
            else
                part.Size = Vector3.new(thickness, height, len)
                part.CFrame = CFrame.new(edge.pos, bandY0 + height * 0.5, mid)
            end
            part.Parent = container
        end
    end
end

local function computeExteriorWindows(edge: Edge, cfg)
    local arr = {}
    local spacing = cfg.Window.Spacing
    local inset = cfg.Window.InsetFromCorner
    local half = cfg.Window.Width * 0.5
    local s = edge.s + inset
    local e = edge.e - inset
    local at = s
    while at + half <= e - half do
        table.insert(arr, { s = at - half, e = at + half })
        at = at + spacing
    end
    return arr
end

local function gatherExteriorEdges(footprint: Rect)
    return {
        { axis = "x", pos = footprint.z0, s = footprint.x0, e = footprint.x1 }, -- south
        { axis = "x", pos = footprint.z1, s = footprint.x0, e = footprint.x1 }, -- north
        { axis = "z", pos = footprint.x0, s = footprint.z0, e = footprint.z1 }, -- west
        { axis = "z", pos = footprint.x1, s = footprint.z0, e = footprint.z1 }, -- east
    }
end

-- Gather all room<->corridor shared edges (interior walls) for junction analysis
local function gatherInteriorEdges(rooms: {Rect}, halls: {Rect})
    local edges: { Edge } = {}
    for _, room in ipairs(rooms) do
        for _, hall in ipairs(halls) do
            local edge = sharedEdge(room, hall)
            if edge then table.insert(edges, edge) end
        end
    end
    return edges
end

local function computeJunctionExclusionsForEdge(exteriorEdge: Edge, interiorEdges: {Edge}, footprint: Rect, clearance: number)
    local exclusions = {}
    if exteriorEdge.axis == "x" then
        -- exterior edge runs along X at z = pos; perpendicular interior edges are axis 'z'
        for _, e in ipairs(interiorEdges) do
            if e.axis == "z" then
                -- e runs from z in [s,e] at x = e.pos; check if it meets this boundary
                if (exteriorEdge.pos >= math.min(e.s, e.e) - 1e-3) and (exteriorEdge.pos <= math.max(e.s, e.e) + 1e-3) then
                    local x = e.pos
                    table.insert(exclusions, { s = x - clearance, e = x + clearance })
                end
            end
        end
    else
        -- exterior edge runs along Z at x = pos; perpendicular interior edges are axis 'x'
        for _, e in ipairs(interiorEdges) do
            if e.axis == "x" then
                if (exteriorEdge.pos >= math.min(e.s, e.e) - 1e-3) and (exteriorEdge.pos <= math.max(e.s, e.e) + 1e-3) then
                    local z = e.pos
                    table.insert(exclusions, { s = z - clearance, e = z + clearance })
                end
            end
        end
    end
    return exclusions
end

-- Corridor connectivity utilities
local function rectsOverlap(a: Rect, b: Rect, eps: number?)
    eps = eps or 1e-3
    local sX = math.max(a.x0, b.x0)
    local eX = math.min(a.x1, b.x1)
    local sZ = math.max(a.z0, b.z0)
    local eZ = math.min(a.z1, b.z1)
    return (eX - sX) > -eps and (eZ - sZ) > -eps
end

local function centerOf(r: Rect)
    return (r.x0 + r.x1) * 0.5, (r.z0 + r.z1) * 0.5
end

-- Ensure all corridor rectangles form a single connected set by adding L-shaped connectors
local function connectCorridors(corridors: {Rect}, footprint: Rect, cw: number)
    if #corridors == 0 then return corridors end
    -- pick root as corridor nearest to building center (0,0) in local space
    local rootIndex = 1
    local bestD = math.huge
    for i, c in ipairs(corridors) do
        local cx, cz = centerOf(c)
        local d = math.abs(cx) + math.abs(cz)
        if d < bestD then bestD = d; rootIndex = i end
    end

    local function recomputeReachable()
        local reachable = {}
        local queue = { rootIndex }
        reachable[rootIndex] = true
        local qi = 1
        while qi <= #queue do
            local i = queue[qi]; qi = qi + 1
            for j = 1, #corridors do
                if not reachable[j] then
                    if rectsOverlap(corridors[i], corridors[j], 0.0) then
                        reachable[j] = true
                        queue[#queue + 1] = j
                    end
                end
            end
        end
        return reachable
    end

    local MAX_CONNECTORS = 64
    local added = 0
    while true do
        local reachable = recomputeReachable()
        local allReachable = true
        local targetIndex = nil
        for i = 1, #corridors do
            if not reachable[i] then
                allReachable = false
                targetIndex = i
                break
            end
        end
        if allReachable or added >= MAX_CONNECTORS then break end

        -- Find nearest reachable corridor to connect to
        local tx, tz = centerOf(corridors[targetIndex])
        local nearestIndex, nearestDist = nil, math.huge
        for i = 1, #corridors do
            if reachable[i] then
                local cx, cz = centerOf(corridors[i])
                local d = math.abs(cx - tx) + math.abs(cz - tz)
                if d < nearestDist then nearestDist, nearestIndex = d, i end
            end
        end
        if not nearestIndex then break end
        local nx, nz = centerOf(corridors[nearestIndex])

        -- L-shaped connection: first along X at z=tz, then along Z at x=nx
        local aX0 = math.min(tx, nx)
        local aX1 = math.max(tx, nx)
        local connA = makeRect(aX0, tz - cw * 0.5, aX1, tz + cw * 0.5)
        local bZ0 = math.min(tz, nz)
        local bZ1 = math.max(tz, nz)
        local connB = makeRect(nx - cw * 0.5, bZ0, nx + cw * 0.5, bZ1)

        corridors[#corridors + 1] = connA
        corridors[#corridors + 1] = connB
        added = added + 2
    end

    return corridors
end

-- Ensure that every room has a doorway to a corridor that is connected
local function ensureRoomAccess(rooms: {Rect}, corridors: {Rect}, doors, cfg)
    local function edgeKey(edge: Edge)
        local function r(v) return string.format("%.2f", v) end
        return table.concat({ edge.axis, r(edge.pos), r(edge.s), r(edge.e) }, ":")
    end

    -- Precompute corridor connectivity (treat touching as connected)
    local reachable = {}
    local queue = { 1 }
    if #corridors == 0 then return doors end
    reachable[1] = true
    local qi = 1
    while qi <= #queue do
        local i = queue[qi]; qi += 1
        for j = 1, #corridors do
            if not reachable[j] then
                if rectsOverlap(corridors[i], corridors[j], 1e-3) then
                    reachable[j] = true
                    queue[#queue + 1] = j
                end
            end
        end
    end

    local minW = math.max(cfg.Door.Width or 6, cfg.Door.MinWidth or 0)
    local added = 0
    for ri, room in ipairs(rooms) do
        local candidate = nil
        local bestLen = -1
        -- If a door already exists on any edge, skip
        local hasDoor = false
        for ci, hall in ipairs(corridors) do
            local e = sharedEdge(room, hall)
            if e then
                if doors[edgeKey(e)] then
                    hasDoor = true; break
                end
                local len = e.e - e.s
                if reachable[ci] and len > bestLen then
                    candidate, bestLen = e, len
                end
            end
        end
        if not hasDoor and candidate and bestLen > 1 then
            local width = math.min(minW, bestLen - 0.2)
            local center = (candidate.s + candidate.e) * 0.5
            doors[edgeKey(candidate)] = { center = center, width = math.max(2, width) }
            added += 1
        end
    end
    if added > 0 and cfg.Debug and cfg.Debug.Print then
        warn(string.format("[Generator] ensureRoomAccess added %d fallback doors", added))
    end
    return doors
end

-- Enforce minimum spacing between doors along the same wall line, then re-ensure access per room
local function enforceDoorSpacing(rooms: {Rect}, corridors: {Rect}, doors, cfg)
    local minSpacing = (cfg.Door and cfg.Door.MinSpacing) or 0
    if minSpacing <= 0 then return doors end

    local function lineKeyFromEdge(axis, pos)
        return axis .. ":" .. string.format("%.3f", pos)
    end
    local function edgeKey(edge: Edge)
        local function r(v) return string.format("%.2f", v) end
        return table.concat({ edge.axis, r(edge.pos), r(edge.s), r(edge.e) }, ":")
    end

    -- Bucket doors per line
    local perLine = {}
    for k, d in pairs(doors) do
        local axis, pos = string.match(k, "^(%a):([%d%.-]+):")
        if axis and pos then
            local lk = axis .. ":" .. pos
            local arr = perLine[lk]
            if not arr then arr = {}; perLine[lk] = arr end
            -- Extract center from key by re-parsing is brittle; store from d
            arr[#arr + 1] = { key = k, center = d.center, width = d.width }
        end
    end

    local kept = {}
    for lk, arr in pairs(perLine) do
        table.sort(arr, function(a,b) return a.center < b.center end)
        local last = -math.huge
        for _, item in ipairs(arr) do
            if item.center - last >= minSpacing then
                kept[item.key] = doors[item.key]
                last = item.center
            end
        end
    end

    -- Re-ensure each room has at least one door after spacing filter
    local filtered = kept
    local minW = math.max(cfg.Door.Width or 6, cfg.Door.MinWidth or 0)
    for _, room in ipairs(rooms) do
        local has = false
        local candidate, bestLen
        for _, hall in ipairs(corridors) do
            local e = sharedEdge(room, hall)
            if e then
                if filtered[edgeKey(e)] then has = true; break end
                local len = e.e - e.s
                if len > (bestLen or -1) then bestLen = len; candidate = e end
            end
        end
        if not has and candidate and bestLen and bestLen > 1 then
            local width = math.min(minW, bestLen - 0.2)
            local center = (candidate.s + candidate.e) * 0.5
            filtered[edgeKey(candidate)] = { center = center, width = math.max(2, width) }
        end
    end

    return filtered
end

-- Final pass: ensure the graph of corridors + rooms (via doors) is a single component.
-- Adds a single fallback door per unreachable room on its longest shared edge to any corridor
-- Iterate up to a safety cap to converge.
local function ensureGlobalConnectivity(rooms: {Rect}, corridors: {Rect}, doors, cfg)
    local function edgeKey(edge: Edge)
        local function r(v) return string.format("%.2f", v) end
        return table.concat({ edge.axis, r(edge.pos), r(edge.s), r(edge.e) }, ":")
    end

    local minW = math.max(cfg.Door.Width or 6, cfg.Door.MinWidth or 0)

    local function computeReachable()
        local rc = #corridors
        if rc == 0 then return {}, {} end
        local reachableC = table.create(rc, false)
        local reachableR = table.create(#rooms, false)
        local q = {}

        local root = 1
        reachableC[root] = true
        q[#q + 1] = { t = "c", i = root }

        while #q > 0 do
            local cur = table.remove(q, 1)
            if cur.t == "c" then
                local i = cur.i
                -- corridor->corridor
                for j = 1, rc do
                    if not reachableC[j] and rectsOverlap(corridors[i], corridors[j], 1e-3) then
                        reachableC[j] = true
                        q[#q + 1] = { t = "c", i = j }
                    end
                end
                -- corridor->room via existing doors
                for r = 1, #rooms do
                    if not reachableR[r] then
                        local e = sharedEdge(rooms[r], corridors[i])
                        if e and doors[edgeKey(e)] then
                            reachableR[r] = true
                            q[#q + 1] = { t = "r", i = r }
                        end
                    end
                end
            else
                local r = cur.i
                -- room->corridor via existing doors
                for j = 1, rc do
                    if not reachableC[j] then
                        local e = sharedEdge(rooms[r], corridors[j])
                        if e and doors[edgeKey(e)] then
                            reachableC[j] = true
                            q[#q + 1] = { t = "c", i = j }
                        end
                    end
                end
            end
        end
        return reachableR, reachableC
    end

    local MAX_ITERS = 24
    for _ = 1, MAX_ITERS do
        local reachableR, reachableC = computeReachable()
        local allOk = true
        for ri = 1, #rooms do
            if not reachableR[ri] then allOk = false break end
        end
        if allOk then break end

        -- Add fallback door for first unreachable room
        for ri = 1, #rooms do
            if not reachableR[ri] then
                local best, bestLen
                for cj = 1, #corridors do
                    -- Prefer corridors that are reachable in current graph
                    if reachableC[cj] then
                        local e = sharedEdge(rooms[ri], corridors[cj])
                        if e then
                            local len = e.e - e.s
                            if len > (bestLen or -1) then best, bestLen = e, len end
                        end
                    end
                end
                if best and bestLen and bestLen > 1 then
                    local width = math.min(minW, bestLen - 0.2)
                    local center = (best.s + best.e) * 0.5
                    doors[edgeKey(best)] = { center = center, width = math.max(2, width) }
                end
                break
            end
        end
    end

    return doors
end

-- Emit interior walls for room<->corridor borders with door holes
local function emitInteriorWalls(container: Instance, rooms: {Rect}, halls: {Rect}, doors, cfg, openingsFolder)
    local color = cfg.Colors.InteriorWalls or cfg.Colors.Walls
    local mats = cfg.Materials or {}
    local mat = mats.InteriorWalls or mats.Walls or Enum.Material.Concrete
    local thick = cfg.WallThickness
    local runPad = math.max(0, (cfg.Door and cfg.Door.Clearance) or 0) -- extra along-wall clearance

    -- Aggregate coverage and openings per unique edge line to avoid seams between adjacent corridor slices
    local lines = {} -- key -> { axis=..., pos=..., covers={}, opens={} }
    local function lineKey(axis, pos)
        return axis .. ":" .. string.format("%.3f", pos)
    end

    for _, room in ipairs(rooms) do
        for _, hall in ipairs(halls) do
            local edge = sharedEdge(room, hall)
            if edge then
                local key = lineKey(edge.axis, edge.pos)
                local entry = lines[key]
                if not entry then
                    entry = { axis = edge.axis, pos = edge.pos, covers = {}, opens = {} }
                    lines[key] = entry
                end
                table.insert(entry.covers, { s = edge.s, e = edge.e })

                -- door opening on this edge
                local function dKey(e: Edge)
                    local function r(v) return string.format("%.2f", v) end
                    return table.concat({ e.axis, r(e.pos), r(e.s), r(e.e) }, ":")
                end
                local d = doors[dKey(edge)]
                if d then
                    local s = d.center - d.width * 0.5 - runPad
                    local e = d.center + d.width * 0.5 + runPad
                    table.insert(entry.opens, { s = s, e = e })
                end
            end
        end
    end

    -- Merge intervals utility
    local function mergeIntervals(ints)
        table.sort(ints, function(a, b) return a.s < b.s end)
        local out = {}
        for _, iv in ipairs(ints) do
            if #out == 0 or iv.s > out[#out].e then
                out[#out + 1] = { s = iv.s, e = iv.e }
            else
                out[#out].e = math.max(out[#out].e, iv.e)
            end
        end
        return out
    end

    for _, entry in pairs(lines) do
        local covers = mergeIntervals(entry.covers)
        local opens = entry.opens
        -- For each cover span, subtract openings and emit one continuous band (full height) to avoid vertical seams
        for _, cov in ipairs(covers) do
            local kept = subtractIntervals(cov.s, cov.e, opens)
            for _, seg in ipairs(kept) do
                local edge = { axis = entry.axis, pos = entry.pos, s = seg.s, e = seg.e }
                emitWallBandParts(container, color, edge, 0, cfg.WallHeight, {}, thick, mat)
            end
        end
        -- Create board-up proxies for each opening on this line (passages)
        if openingsFolder then
            for _, iv in ipairs(opens) do
                local s, e = iv.s, iv.e
                if e > s then
                    local mid = (s + e) * 0.5
                    local len = e - s
                    local h = cfg.WallHeight
                    local thickLocal = math.max(0.2, cfg.WallThickness - 0.05)
                    local p = Instance.new("Part")
                    p.Name = "Opening_Passage"
                    p.Anchored = true
                    p.CanCollide = false
                    p.Transparency = 1
                    p.Material = Enum.Material.Air
                    if entry.axis == "x" then
                        p.Size = Vector3.new(len, h, thickLocal)
                        p.CFrame = CFrame.new(mid, h * 0.5, entry.pos)
                    else
                        p.Size = Vector3.new(thickLocal, h, len)
                        p.CFrame = CFrame.new(entry.pos, h * 0.5, mid)
                    end
                    p:SetAttribute("Axis", entry.axis)
                    p:SetAttribute("Pos", entry.pos)
                    p:SetAttribute("S", s)
                    p:SetAttribute("E", e)
                    p:SetAttribute("Y0", 0)
                    p:SetAttribute("Y1", h)
                    p:SetAttribute("Kind", "Passage")
                    p.Parent = openingsFolder

                    local boardCfg = cfg.BOARDUP or {}
                    local prompt = Instance.new("ProximityPrompt")
                    prompt.ActionText = "Board Up"
                    prompt.ObjectText = "Passage"
                    prompt.HoldDuration = boardCfg.Hold or 0.2
                    prompt.MaxActivationDistance = boardCfg.Distance or 12
                    prompt.KeyboardKeyCode = boardCfg.KeyCode or Enum.KeyCode.E
                    prompt.RequiresLineOfSight = false
                    prompt.Parent = p
                end
            end
        end
    end
end

-- Emit exterior walls with doors and window openings
local function emitExteriorWalls(container: Instance, footprint: Rect, exteriorDoors, cfg, interiorEdges, openingsFolder)
    local color = cfg.Colors.Walls
    local mats = cfg.Materials or {}
    local mat = mats.Walls or Enum.Material.Concrete
    local doorH = cfg.Door.Height
    local sill = cfg.Window.SillHeight
    local wTop = sill + cfg.Window.Height
    local thick = cfg.WallThickness
    local edges = gatherExteriorEdges(footprint)

    local function unionIntervals(a, b)
        if #a == 0 then return b end
        if #b == 0 then return a end
        local out = {}
        for i = 1, #a do out[#out + 1] = a[i] end
        for i = 1, #b do out[#out + 1] = b[i] end
        return out
    end

    local clearance = (cfg.Window and (cfg.Window.JunctionClearance or 0)) or 0
    if clearance <= 0 then clearance = math.max(cfg.WallThickness, 2) end

    for _, edge in ipairs(edges) do
        local doorIntervals = {}
        for _, d in ipairs(exteriorDoors) do
            if (d.axis == "x" and edge.axis == "x" and math.abs(d.pos - edge.pos) < 1e-3)
                or (d.axis == "z" and edge.axis == "z" and math.abs(d.pos - edge.pos) < 1e-3) then
                table.insert(doorIntervals, { s = d.center - d.width * 0.5, e = d.center + d.width * 0.5 })
            end
        end

        local windowIntervals = computeExteriorWindows(edge, cfg)
        -- Drop any windows too close to interior wall junctions
        local exclusions = computeJunctionExclusionsForEdge(edge, interiorEdges or {}, footprint, clearance)
        if #exclusions > 0 then
            local filtered = {}
            for _, w in ipairs(windowIntervals) do
                local keep = true
                for _, ex in ipairs(exclusions) do
                    local s = math.max(w.s, ex.s)
                    local e = math.min(w.e, ex.e)
                    if e > s then keep = false; break end
                end
                if keep then table.insert(filtered, w) end
            end
            windowIntervals = filtered
        end

        -- Non-overlapping vertical bands to avoid blocking doors with window bands
        local y0 = 0
        local yA1 = math.min(doorH, sill)
        local yB0 = yA1
        local yB1 = math.max(doorH, sill)
        local yC0 = yB1
        local yC1 = wTop
        local yD0 = math.max(doorH, wTop)
        local yTop = cfg.WallHeight

        if yA1 > y0 then
            emitWallBandParts(container, color, edge, y0, yA1, doorIntervals, thick, mat)
        end
        if yB1 > yB0 then
            emitWallBandParts(container, color, edge, yB0, yB1, unionIntervals(doorIntervals, windowIntervals), thick, mat)
        end
        if yC1 > yC0 then
            emitWallBandParts(container, color, edge, yC0, yC1, windowIntervals, thick, mat)
        end
        if yTop > yD0 then
            emitWallBandParts(container, color, edge, yD0, yTop, {}, thick, mat)
        end
        -- Register openings for board-up
        if openingsFolder then
            local function register(kind, interval, oy0, oy1)
                local s, e = interval.s, interval.e
                if e <= s then return end
                local mid = (s + e) * 0.5
                local h = math.max(0.1, oy1 - oy0)
                local len = e - s
                local thickLocal = math.max(0.2, cfg.WallThickness - 0.05)
                local p = Instance.new("Part")
                p.Name = string.format("Opening_%s", kind)
                p.Anchored = true
                p.CanCollide = false
                p.Transparency = 1
                p.Material = Enum.Material.Air
                if edge.axis == "x" then
                    p.Size = Vector3.new(len, h, thickLocal)
                    p.CFrame = CFrame.new(mid, oy0 + h * 0.5, edge.pos)
                else
                    p.Size = Vector3.new(thickLocal, h, len)
                    p.CFrame = CFrame.new(edge.pos, oy0 + h * 0.5, mid)
                end
                p:SetAttribute("Axis", edge.axis)
                p:SetAttribute("Pos", edge.pos)
                p:SetAttribute("S", s)
                p:SetAttribute("E", e)
                p:SetAttribute("Y0", oy0)
                p:SetAttribute("Y1", oy1)
                p:SetAttribute("Kind", kind)
                p.Parent = openingsFolder

                local boardCfg = cfg.BOARDUP or {}
                local prompt = Instance.new("ProximityPrompt")
                prompt.ActionText = "Board Up"
                prompt.ObjectText = kind
                prompt.HoldDuration = boardCfg.Hold or 0.2
                prompt.MaxActivationDistance = boardCfg.Distance or 12
                prompt.KeyboardKeyCode = boardCfg.KeyCode or Enum.KeyCode.E
                prompt.RequiresLineOfSight = false
                prompt.Parent = p
            end
            for _, d in ipairs(doorIntervals) do register("DoorExterior", d, 0, doorH) end
            for _, w in ipairs(windowIntervals) do register("Window", w, sill, wTop) end
        end
    end
end

-- Emit solid walls between room-room shared borders (no door openings)
local function emitRoomToRoomWalls(container: Instance, rooms: {Rect}, cfg)
    local color = cfg.Colors.InteriorWalls or cfg.Colors.Walls
    local thick = cfg.WallThickness
    local h = cfg.WallHeight
    for i = 1, #rooms do
        for j = i + 1, #rooms do
            local a = rooms[i]
            local b = rooms[j]
            local edge = sharedEdge(a, b)
            if edge then
                emitWallBandParts(container, color, edge, 0, h, {}, thick)
            end
        end
    end
end

-- Optional debug: visualize rectangles as thin parts
local function visualizeRects(container: Instance, rooms: {Rect}, halls: {Rect}, cfg)
    if not (cfg.Debug and cfg.Debug.VisualizeRects) then return end
    local function addRect(r: Rect, color: Color3, y: number)
        local p = Instance.new("Part")
        p.Anchored = true
        p.CanCollide = false
        p.Transparency = 0.6
        p.Color = color
        local cx, cz = rectCenter(r)
        p.Size = Vector3.new(math.max(0.2, rectWidth(r) - 0.4), 0.2, math.max(0.2, rectLength(r) - 0.4))
        p.CFrame = CFrame.new(cx, y, cz)
        p.Parent = container
    end
    for _, r in ipairs(rooms) do addRect(r, Color3.fromRGB(100, 200, 100), 0.2) end
    for _, h in ipairs(halls) do addRect(h, Color3.fromRGB(200, 100, 100), 0.4) end
end

-- Emit flat floor parts for corridors/rooms (optional)
local function emitFloors(container: Instance, rects: {Rect}, color: Color3, material: Enum.Material?, yOffset: number)
    for _, r in ipairs(rects) do
        local p = Instance.new("Part")
        p.Anchored = true
        p.CanCollide = true
        p.TopSurface = Enum.SurfaceType.Smooth
        p.BottomSurface = Enum.SurfaceType.Smooth
        p.Color = color
        if material then p.Material = material end
        local cx, cz = rectCenter(r)
        p.Size = Vector3.new(rectWidth(r), 0.2, rectLength(r))
        p.CFrame = CFrame.new(cx, 0.1 + (yOffset or 0), cz)
        p.Parent = container
    end
end

local function emitSlab(container: Instance, name: string, rect: Rect, wallThick: number, extend: number, y: number, thickness: number, color: Color3, material: Enum.Material?, fillUnderExteriorWalls: boolean?)
    local x0, x1, z0, z1
    if fillUnderExteriorWalls then
        -- Expand to include area beneath exterior walls
        x0 = rect.x0 - wallThick * 0.5 - (extend or 0)
        x1 = rect.x1 + wallThick * 0.5 + (extend or 0)
        z0 = rect.z0 - wallThick * 0.5 - (extend or 0)
        z1 = rect.z1 + wallThick * 0.5 + (extend or 0)
    else
        -- Shrink so we DO NOT place slab under exterior walls
        x0 = rect.x0 + wallThick * 0.5 + (extend or 0)
        x1 = rect.x1 - wallThick * 0.5 - (extend or 0)
        z0 = rect.z0 + wallThick * 0.5 + (extend or 0)
        z1 = rect.z1 - wallThick * 0.5 - (extend or 0)
    end
    local cx = (x0 + x1) * 0.5
    local cz = (z0 + z1) * 0.5
    local p = Instance.new("Part")
    p.Name = name
    p.Anchored = true
    p.CanCollide = true
    p.TopSurface = Enum.SurfaceType.Smooth
    p.BottomSurface = Enum.SurfaceType.Smooth
    p.Color = color
    if material then p.Material = material end
    p.Size = Vector3.new(math.max(0.2, x1 - x0), thickness, math.max(0.2, z1 - z0))
    p.CFrame = CFrame.new(cx, y + thickness * 0.5, cz)
    p.Parent = container
end

-- Public API: Generate a building Model at originCFrame (floor aligned), returns the created Model
function Generator.Generate(originCFrame: CFrame, cfg)
    assert(originCFrame ~= nil, "originCFrame required")
    assert(cfg ~= nil, "cfg required")

    local rng = Random.new(cfg.Seed or os.clock())
    local fpW = cfg.Footprint.Width
    local fpL = cfg.Footprint.Length
    local halfW = fpW * 0.5
    local halfL = fpL * 0.5

    -- Build in local space centered at (0,0); we will transform to origin at the end
    local footprint = makeRect(-halfW, -halfL, halfW, halfL)

    local rooms, corridors = bspPartition(rng, footprint, cfg)
    local extDoors
    extDoors, corridors = planExteriorDoorsAndEntrances(rng, footprint, corridors, cfg)
    -- Force corridor graph to be connected to avoid isolated areas
    corridors = connectCorridors(corridors, footprint, cfg.CorridorWidth)
    local doors = planDoors(rng, rooms, corridors, cfg)
    doors = ensureRoomAccess(rooms, corridors, doors, cfg)
    doors = enforceDoorSpacing(rooms, corridors, doors, cfg)
    doors = ensureGlobalConnectivity(rooms, corridors, doors, cfg)

    local model = Instance.new("Model")
    model.Name = "GeneratedBuilding"

    local wallsFolder = Instance.new("Folder"); wallsFolder.Name = "Walls"; wallsFolder.Parent = model
    local floorsFolder = Instance.new("Folder"); floorsFolder.Name = "Floors"; floorsFolder.Parent = model
    local roofFolder = Instance.new("Folder"); roofFolder.Name = "Roof"; roofFolder.Parent = model
    local openingsFolder = Instance.new("Folder"); openingsFolder.Name = "Openings"; openingsFolder.Parent = model

    visualizeRects(model, rooms, corridors, cfg)

    if cfg.GenerateFloors then
        local mats = cfg.Materials or {}
        local offset = (cfg.Slab and cfg.Slab.FloorOffset) or 0
        emitFloors(floorsFolder, rooms, cfg.Colors.Rooms, mats.Floor or Enum.Material.Wood, offset)
        emitFloors(floorsFolder, corridors, cfg.Colors.Corridors, mats.Floor or Enum.Material.Wood, offset)
    end

    -- Single floor slab under everything
    if cfg.GenerateFloorSlab ~= false then
        local slabCfg = cfg.Slab or { FloorThickness = 1, Extend = 0 }
        local mats = cfg.Materials or {}
        local offset = slabCfg.FloorOffset or 0
        -- Do not place floor under exterior walls: pass fillUnderExteriorWalls=false
        emitSlab(floorsFolder, "FloorSlab", footprint, cfg.WallThickness, slabCfg.Extend or 0, 0 + offset, slabCfg.FloorThickness or 1, cfg.Colors.Floor or cfg.Colors.Rooms, mats.Floor or Enum.Material.Wood, false)
    end

    -- Single roof slab above everything
    if cfg.GenerateRoof ~= false then
        local slabCfg = cfg.Slab or { RoofThickness = 1, Extend = 0 }
        local mats = cfg.Materials or {}
        local yTop = cfg.WallHeight
        -- Roof can extend under exterior walls for better coverage
        emitSlab(roofFolder, "RoofSlab", footprint, cfg.WallThickness, slabCfg.Extend or 0, yTop, slabCfg.RoofThickness or 1, cfg.Colors.Roof or cfg.Colors.Walls, mats.Roof or Enum.Material.SmoothPlastic, true)
    end

    -- Interior walls between rooms and corridors
    emitInteriorWalls(wallsFolder, rooms, corridors, doors, cfg, openingsFolder)
    -- Exterior walls with windows and exterior doors
    local interiorEdges = gatherInteriorEdges(rooms, corridors)
    emitExteriorWalls(wallsFolder, footprint, extDoors, cfg, interiorEdges, openingsFolder)

    -- Compute largest room center (in local space), then transform to world space
    local largestArea = -1
    local largestCenterLocal: Vector3? = nil
    for _, r in ipairs(rooms) do
        local area = rectWidth(r) * rectLength(r)
        if area > largestArea then
            largestArea = area
            local cx, cz = rectCenter(r)
            largestCenterLocal = Vector3.new(cx, 0, cz)
        end
    end

    local largestCenterWorld: Vector3? = nil
    if largestCenterLocal then
        largestCenterWorld = originCFrame:ToWorldSpace(CFrame.new(largestCenterLocal)).Position
    end

    -- Determine floor top in local space (slab vs patches)
    local slabOffset = (cfg.Slab and cfg.Slab.FloorOffset) or 0
    local slabThickness = (cfg.Slab and cfg.Slab.FloorThickness) or 1
    local haveSlab = (cfg.GenerateFloorSlab ~= false)
    local havePatches = (cfg.GenerateFloors == true)

    local slabTopLocal = haveSlab and (slabThickness + slabOffset) or 0
    local slabTopLocalBase = haveSlab and (slabThickness) or 0
    local patchTopLocal = havePatches and (0.2 + slabOffset) or 0
    local patchTopLocalBase = havePatches and 0.2 or 0

    local floorTopLocal = math.max(slabTopLocal, patchTopLocal)
    local floorBaseLocal = math.max(slabTopLocalBase, patchTopLocalBase)
    local floorTopWorld = originCFrame.Position.Y + floorTopLocal
    local floorBaseWorld = originCFrame.Position.Y + floorBaseLocal

    -- Transform to originCFrame (rotation+translation); since we only used identity rotation, apply the full CFrame to children
    for _, inst in ipairs(model:GetDescendants()) do
        if inst:IsA("BasePart") then
            inst.CFrame = originCFrame:ToWorldSpace(inst.CFrame)
        end
    end

    model.Parent = Workspace
    return model, { largestRoomCenter = largestCenterWorld, floorTopY = floorTopWorld, floorBaseY = floorBaseWorld }
end

return Generator
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="4">
      <Properties>
        <string name="Name">Net</string>
      </Properties>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">Events</string>
          <string name="Source"><![CDATA[-- Centralized RemoteEvent/RemoteFunction registry

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local Events = {}

local function ensure(name, className)
    local folder = ReplicatedStorage:FindFirstChild("Remotes")
    if not folder then
        if RunService:IsServer() then
            folder = Instance.new("Folder")
            folder.Name = "Remotes"
            folder.Parent = ReplicatedStorage
        else
            folder = ReplicatedStorage:WaitForChild("Remotes", 10)
        end
    end

    local obj = folder and folder:FindFirstChild(name) or nil
    if not obj then
        if RunService:IsServer() then
            obj = Instance.new(className)
            obj.Name = name
            obj.Parent = folder
        else
            obj = folder and folder:WaitForChild(name, 10) or nil
        end
    end
    return obj
end

Events.RoundChanged = ensure("RoundChanged", "RemoteEvent")
Events.RequestSpawn = ensure("RequestSpawn", "RemoteFunction")
Events.UseGadget = ensure("UseGadget", "RemoteEvent")
Events.FireWeapon = ensure("FireWeapon", "RemoteEvent")
Events.HitConfirm = ensure("HitConfirm", "RemoteEvent")
Events.Objective = ensure("ObjectiveEvent", "RemoteEvent")
-- Construction/building requests
Events.Construction = ensure("ConstructionRequest", "RemoteEvent")
Events.BoardUp = ensure("BoardUpRequest", "RemoteEvent")
Events.BoardKick = ensure("BoardKickRequest", "RemoteEvent")
Events.BoardFX = ensure("BoardFX", "RemoteEvent")
-- Debug/minimap update
Events.ConstructionMap = ensure("ConstructionMap", "RemoteEvent")

return Events
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="6">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">Config</string>
          <string name="Source"><![CDATA[-- Central game configuration (shared)

local Config = {
    forceR6 = true,

    baseplate = {
        size = Vector3.new(512, 1, 512),
        color = Color3.fromRGB(163, 162, 165),
        name = "Baseplate",
    },

    spawns = {
        inset = 10,
        size = Vector3.new(8, 1, 8),
        forceFieldDuration = 0,
    },

    teams = {
        red = { name = "Red", brickColor = "Really red" },
        green = { name = "Green", brickColor = "Lime green" },
        autoAssignable = false,
        assignment = "alternate",
    },

    -- Debug: Team colors should be different
    DEBUG_TEAM_COLORS_DIFFERENT = true,

    ROUND = { LENGTH_SEC = 180, WIN_TARGET = 3, SWITCH_SIDES_EVERY = 2 },

    WEAPONS = {
        RateLimit = 120,  -- requests per minute
    },

    OBJECTIVE = {
        Size = Vector3.new(2, 2, 2),
        Position = Vector3.new(0, 1, 0),
        Color = Color3.fromRGB(255, 219, 77),
    },

    EXTRACT = {
        Size = Vector3.new(10, 1, 10),
        Position = Vector3.new(0, 0.5, 80),
        Color = Color3.fromRGB(120, 200, 255),
    },

    -- Procedural Construction / Building Generation
    CONSTRUCTION = {
        Seed = 1337,
        Footprint = { Width = 100, Length = 80 },
        Floors = 1,

        -- Structure
        WallHeight = 16.8, -- +20% from 14
        WallThickness = 2,
        CorridorWidth = 12,

        -- Rooms (BSP partition constraints)
        Room = {
            MinSize = { Width = 16, Length = 14 },
            MaxSize = { Width = 34, Length = 28 },
        },

        -- Openings
        Door = { Width = 10, MinWidth = 12, Height = 9, Clearance = 3, MinSpacing = 18 },
        ExteriorDoors = 2,
        Window = {
            Width = 6,
            Height = 5,
            SillHeight = 4,
            Spacing = 8, -- center-to-center along exterior walls
            InsetFromCorner = 4, -- keep windows away from corners
        },

        -- Colors/Style
        Colors = {
            Walls = Color3.fromRGB(150, 150, 150),      -- grey walls
            InteriorWalls = Color3.fromRGB(150, 150, 150),
            Corridors = Color3.fromRGB(170, 170, 170),
            Rooms = Color3.fromRGB(210, 210, 210),
            Floor = Color3.fromRGB(140, 110, 80),       -- wood tone
            Roof = Color3.fromRGB(255, 255, 255),       -- white ceiling
        },
        Materials = {
            Walls = Enum.Material.Concrete,
            InteriorWalls = Enum.Material.Concrete,
            Floor = Enum.Material.Wood,
            Roof = Enum.Material.SmoothPlastic,
        },

        -- Generation toggles
        GenerateFloors = false, -- per-room/corridor thin floor patches
        GenerateFloorSlab = true, -- one big floor under whole building
        GenerateRoof = true,      -- one big roof above walls
        Slab = { FloorThickness = 1, RoofThickness = 1, Extend = 0, FloorOffset = 0.5 },
        Debug = {
            Print = true,
            VisualizeRects = false,
            Randomize = true,
        },

        BOARDUP = {
            PlankWidth = 1.5,
            PlankThickness = 0.2,
            Hold = 0.2,
            MaxBoardsPerOpening = 24,
            MaxPerMinute = 30,
            KeyCode = Enum.KeyCode.E,
            Distance = 12,
            Material = Enum.Material.WoodPlanks,
            Color = Color3.fromRGB(155, 120, 80),
        },

        DESTROY = {
            KeyCode = Enum.KeyCode.Q,
            Cooldown = 0.25,
            MaxPerMinute = 60,
            Distance = 12,
            DoubleBreakChance = 0.25,
            StrongBreakMax = 4, -- max boards removed on a strong kick
            Shake = { Mag = 0.5, Duration = 0.12 },
        },
    },
}

return Config
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="8">
        <Properties>
          <string name="Name">ConfigLoader</string>
          <string name="Source"><![CDATA[-- Centralized configuration loading utility
-- Eliminates duplication and ensures consistent fallback behavior

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ConfigLoader = {}

local function getDefaultConfig()
    return {
        forceR6 = true,
        baseplate = {
            size = Vector3.new(512,1,512),
            color = Color3.fromRGB(163,162,165),
            name = "Baseplate"
        },
        spawns = {
            inset = 10,
            size = Vector3.new(8,1,8),
            forceFieldDuration = 0
        },
        teams = {
            red = { name = "Red", brickColor = "Really red" },
            green = { name = "Green", brickColor = "Lime green" },
            autoAssignable = false,
            assignment = "alternate",
        },
        ROUND = { LENGTH_SEC = 180, WIN_TARGET = 3, SWITCH_SIDES_EVERY = 2 },
    }
end

function ConfigLoader.Load(moduleName: string?)
    -- Try to load from Shared/Config first
    local ok, config
    ok, config = pcall(function()
        local shared = ReplicatedStorage:FindFirstChild("Shared")
        if shared then
            local cfg = shared:FindFirstChild("Config") or shared:WaitForChild("Config", 5)
            if cfg then return require(cfg) end
        end
        return nil
    end)

    if ok and config then return config end

    -- Fallback to direct ReplicatedStorage/Config
    ok, config = pcall(function()
        local cfg = ReplicatedStorage:FindFirstChild("Config") or ReplicatedStorage:WaitForChild("Config", 5)
        if cfg then return require(cfg) end
        return nil
    end)

    if ok and config then return config end

    -- Final fallback to defaults with warning
    warn(string.format("[ConfigLoader] Using default config; ReplicatedStorage.Shared.Config not found%s",
        moduleName and " (requested by " .. moduleName .. ")" or ""))
    return getDefaultConfig()
end

return ConfigLoader
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="9">
      <Properties>
        <string name="Name">Assets</string>
      </Properties>
      <Item class="Tool" referent="10">
        <Properties>
          <string name="Name">Briefcase</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <bool name="CanBeDropped">true</bool>
          <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
          <bool name="Enabled">true</bool>
          <CoordinateFrame name="Grip">
            <X>0</X>
            <Y>0.125</Y>
            <Z>1.25</Z>
            <R00>-0.9999996</R00>
            <R01>0.000000004732249</R01>
            <R02>0.0008574165</R02>
            <R10>0.00085741637</R10>
            <R11>0.0000055191936</R11>
            <R12>0.9999997</R12>
            <R20>0</R20>
            <R21>1</R21>
            <R22>-0.000005519196</R22>
          </CoordinateFrame>
          <token name="LevelOfDetail">0</token>
          <bool name="ManualActivationOnly">false</bool>
          <CoordinateFrame name="ModelMeshCFrame">
            <X>0</X>
            <Y>0</Y>
            <Z>0</Z>
            <R00>1</R00>
            <R01>0</R01>
            <R02>0</R02>
            <R10>0</R10>
            <R11>1</R11>
            <R12>0</R12>
            <R20>0</R20>
            <R21>0</R21>
            <R22>1</R22>
          </CoordinateFrame>
          <SharedString name="ModelMeshData">rxNJufX5oaagQE3qNtzJSQ==</SharedString>
          <Vector3 name="ModelMeshSize">
            <X>0</X>
            <Y>0</Y>
            <Z>0</Z>
          </Vector3>
          <token name="ModelStreamingMode">0</token>
          <bool name="NeedsPivotMigration">false</bool>
          <Ref name="PrimaryPart">null</Ref>
          <bool name="RequiresHandle">true</bool>
          <bool name="DefinesCapabilities">false</bool>
          <float name="ScaleFactor">1</float>
          <int64 name="SourceAssetId">530795465</int64>
          <BinaryString name="Tags"></BinaryString>
          <ContentId name="TextureId">
            <url>rbxgameasset://Images/9c4df27ee4c4d1a2ff5d59b60b3f35f5</url>
          </ContentId>
          <string name="ToolTip"></string>
          <OptionalCoordinateFrame name="WorldPivotData">
            <CFrame>
              <X>60.954716</X>
              <Y>8.619446</Y>
              <Z>-59.32104</Z>
              <R00>0.012972977</R00>
              <R01>0.9997472</R01>
              <R02>-0.018369326</R02>
              <R10>-0.0011690904</R10>
              <R11>0.01838599</R11>
              <R12>0.9998305</R12>
              <R20>0.99991536</R20>
              <R21>-0.012949357</R21>
              <R22>0.0014071371</R22>
            </CFrame>
          </OptionalCoordinateFrame>
        </Properties>
        <Item class="Part" referent="11">
          <Properties>
            <string name="Name">Handle</string>
            <bool name="Anchored">false</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <bool name="AudioCanCollide">true</bool>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>60.955433</X>
              <Y>8.606905</Y>
              <Z>-59.28356</Z>
              <R00>0.01297298</R00>
              <R01>0.9997472</R01>
              <R02>-0.01836932</R02>
              <R10>-0.0011690775</R10>
              <R11>0.018385995</R11>
              <R12>0.9998305</R12>
              <R20>0.99991536</R20>
              <R21>-0.012949354</R21>
              <R22>0.00140715</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <bool name="CastShadow">true</bool>
            <string name="CollisionGroup">Default</string>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">10724005</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <bool name="EnableFluidForces">true</bool>
            <token name="formFactorRaw">3</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">true</bool>
            <bool name="Massless">false</bool>
            <token name="Material">256</token>
            <string name="MaterialVariantSerialized"></string>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <bool name="DefinesCapabilities">false</bool>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>0.5</X>
              <Y>2.375</Y>
              <Z>2</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">1</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
          <Item class="SpecialMesh" referent="12">
            <Properties>
              <string name="Name">Mesh</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <ContentId name="MeshId">
                <url>http://www.roblox.com/asset/?id=314612480</url>
              </ContentId>
              <token name="MeshType">5</token>
              <Vector3 name="Offset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <bool name="DefinesCapabilities">false</bool>
              <Vector3 name="Scale">
                <X>1</X>
                <Y>1</Y>
                <Z>1</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <ContentId name="TextureId">
                <url>rbxassetid://530784560</url>
              </ContentId>
              <Vector3 name="VertexColor">
                <X>1</X>
                <Y>1</Y>
                <Z>1</Z>
              </Vector3>
            </Properties>
          </Item>
        </Item>
        <Item class="Animation" referent="13">
          <Properties>
            <string name="Name">Throw</string>
            <ContentId name="AnimationId">
              <url>http://www.roblox.com/asset/?id=314726307</url>
            </ContentId>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <bool name="DefinesCapabilities">false</bool>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="Model" referent="14">
          <Properties>
            <string name="Name">DisplayModel</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <token name="LevelOfDetail">0</token>
            <CoordinateFrame name="ModelMeshCFrame">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <SharedString name="ModelMeshData">rxNJufX5oaagQE3qNtzJSQ==</SharedString>
            <Vector3 name="ModelMeshSize">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="ModelStreamingMode">0</token>
            <bool name="NeedsPivotMigration">false</bool>
            <Ref name="PrimaryPart">null</Ref>
            <bool name="DefinesCapabilities">false</bool>
            <float name="ScaleFactor">1</float>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <OptionalCoordinateFrame name="WorldPivotData">
              <CFrame>
                <X>60.954002</X>
                <Y>8.631988</Y>
                <Z>-59.35852</Z>
                <R00>0.012973003</R00>
                <R01>0.9997472</R01>
                <R02>-0.018369308</R02>
                <R10>-0.0011690003</R10>
                <R11>0.018386004</R11>
                <R12>0.99983037</R12>
                <R20>0.99991524</R20>
                <R21>-0.012949327</R21>
                <R22>0.0014072262</R22>
              </CFrame>
            </OptionalCoordinateFrame>
          </Properties>
          <Item class="Part" referent="15">
            <Properties>
              <string name="Name">Bottom</string>
              <bool name="Anchored">false</bool>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <bool name="AudioCanCollide">true</bool>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>60.954002</X>
                <Y>8.631988</Y>
                <Z>-59.35852</Z>
                <R00>0.012973003</R00>
                <R01>0.9997472</R01>
                <R02>-0.018369308</R02>
                <R10>-0.0011690003</R10>
                <R11>0.018386004</R11>
                <R12>0.99983037</R12>
                <R20>0.99991524</R20>
                <R21>-0.012949327</R21>
                <R22>0.0014072262</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">true</bool>
              <bool name="CanTouch">true</bool>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <bool name="CastShadow">true</bool>
              <string name="CollisionGroup">Default</string>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>true</CustomPhysics>
                <Density>0.7</Density>
                <Friction>2</Friction>
                <Elasticity>0</Elasticity>
                <FrictionWeight>1</FrictionWeight>
                <ElasticityWeight>1</ElasticityWeight>
              </PhysicalProperties>
              <bool name="EnableFluidForces">true</bool>
              <token name="formFactorRaw">3</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">true</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <string name="MaterialVariantSerialized"></string>
              <CoordinateFrame name="PivotOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <bool name="DefinesCapabilities">false</bool>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>0.5</X>
                <Y>2.375</Y>
                <Z>2</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">0</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="SpecialMesh" referent="16">
              <Properties>
                <string name="Name">Mesh</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
                <ContentId name="MeshId">
                  <url>rbxassetid://314612480</url>
                </ContentId>
                <token name="MeshType">5</token>
                <Vector3 name="Offset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <bool name="DefinesCapabilities">false</bool>
                <Vector3 name="Scale">
                  <X>1</X>
                  <Y>1</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <ContentId name="TextureId">
                  <url>rbxassetid://530784560</url>
                </ContentId>
                <Vector3 name="VertexColor">
                  <X>1</X>
                  <Y>1</Y>
                  <Z>1</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Weld" referent="17">
              <Properties>
                <string name="Name">Weld</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <CoordinateFrame name="C0">
                  <X>-16.95612</X>
                  <Y>11.309875</Y>
                  <Z>-12.0717325</Z>
                  <R00>0.35382122</R00>
                  <R01>-0.53900504</R01>
                  <R02>0.76438487</R02>
                  <R10>0.9075668</R10>
                  <R11>0.0002695322</R11>
                  <R12>-0.41990775</R12>
                  <R20>0.22612631</R20>
                  <R21>0.8423026</R21>
                  <R22>0.48927838</R22>
                </CoordinateFrame>
                <CoordinateFrame name="C1">
                  <X>-16.881119</X>
                  <Y>11.309875</Y>
                  <Z>-12.096732</Z>
                  <R00>0.35382122</R00>
                  <R01>-0.53900504</R01>
                  <R02>0.76438487</R02>
                  <R10>0.9075668</R10>
                  <R11>0.0002695322</R11>
                  <R12>-0.41990775</R12>
                  <R20>0.22612631</R20>
                  <R21>0.8423026</R21>
                  <R22>0.48927838</R22>
                </CoordinateFrame>
                <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
                <bool name="Enabled">true</bool>
                <Ref name="Part0">11</Ref>
                <Ref name="Part1">15</Ref>
                <bool name="DefinesCapabilities">false</bool>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Camera" referent="18">
          <Properties>
            <string name="Name">ThumbnailCamera</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <CoordinateFrame name="CFrame">
              <X>61.023235</X>
              <Y>10.088793</Y>
              <Z>-60.429394</Z>
              <R00>-1</R00>
              <R01>-0.000015586735</R01>
              <R02>0.000015258822</R02>
              <R10>-0.0000000000009094947</R10>
              <R11>0.6995502</R11>
              <R12>0.7145835</R12>
              <R20>-0.000021812335</R20>
              <R21>0.7145835</R21>
              <R22>-0.6995502</R22>
            </CoordinateFrame>
            <Ref name="CameraSubject">null</Ref>
            <token name="CameraType">0</token>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <float name="FieldOfView">70</float>
            <token name="FieldOfViewMode">0</token>
            <CoordinateFrame name="Focus">
              <X>61.023205</X>
              <Y>8.659629</Y>
              <Z>-59.030296</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <bool name="HeadLocked">true</bool>
            <float name="HeadScale">1</float>
            <bool name="DefinesCapabilities">false</bool>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <bool name="VRTiltAndRollEnabled">false</bool>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="19">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="20">
      <Properties>
        <string name="Name">AntiCheat</string>
      </Properties>
      <Item class="ModuleScript" referent="21">
        <Properties>
          <string name="Name">RateLimiter</string>
          <string name="Source"><![CDATA[local RateLimiter = {}
local buckets = {} -- [userId][key] = {count, t0}

function RateLimiter.Allow(player, key, perMinute)
    local now = os.clock()
    local u = player.UserId
    buckets[u] = buckets[u] or {}
    local b = buckets[u][key]
    if not b or now - b.t0 > 60 then b = {count=0, t0=now}; buckets[u][key]=b end
    if b.count >= perMinute then return false end
    b.count += 1
    return true
end

return RateLimiter

]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Script" referent="22">
      <Properties>
        <string name="Name">Construction</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- Bootstrap for ConstructionService to keep concerns separated
local ConstructionService = require(script.Parent.ConstructionService)
-- Nothing else needed; module self-initializes

]]></string>
      </Properties>
      <Item class="ModuleScript" referent="23">
        <Properties>
          <string name="Name">BoardUpService</string>
          <string name="Source"><![CDATA[-- BoardUpService: allows players to board up openings (doors/windows/passages)

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local RateLimiter = require(game.ServerScriptService.AntiCheat.RateLimiter)

local BoardUpService = {}

local DEFAULT = {
    PlankWidth = 1.5,
    PlankThickness = 0.2,
    Hold = 0.2,
    MaxBoardsPerOpening = 24,
    MaxPerMinute = 30,
    KeyCode = Enum.KeyCode.E,
    Distance = 12,
    Material = Enum.Material.WoodPlanks,
    Color = Color3.fromRGB(155, 120, 80),
}

local function getCfg(cfg)
    local out = {}
    for k,v in pairs(DEFAULT) do out[k] = (cfg and cfg[k]) or v end
    return out
end

local function computeQuota(proxy: BasePart, cfg)
    local axis = proxy:GetAttribute("Axis") or "x"
    local length = (axis == "x") and proxy.Size.X or proxy.Size.Z
    local N = math.max(1, math.ceil(length / cfg.PlankWidth))
    N = math.min(N, cfg.MaxBoardsPerOpening)
    local boards = proxy:FindFirstChild("Boards")
    local current = boards and #boards:GetChildren() or 0
    return N, current
end

local function setPromptEnabled(proxy: BasePart, enabled: boolean)
    local pp = proxy:FindFirstChildOfClass("ProximityPrompt")
    if pp then
        pp.Enabled = enabled
        if not enabled then pp.ObjectText = "Sealed" end
    end
end

local function ensureKickPrompt(proxy: BasePart, cfg)
    local prompt = proxy:FindFirstChild("KickPrompt")
    if not prompt then
        prompt = Instance.new("ProximityPrompt")
        prompt.Name = "KickPrompt"
        prompt.ActionText = "Kick"
        prompt.ObjectText = "Boards"
        prompt.HoldDuration = 0
        prompt.RequiresLineOfSight = false
        prompt.Parent = proxy
    end
    prompt.KeyboardKeyCode = (cfg and cfg.KeyCode) or Enum.KeyCode.Q
    prompt.MaxActivationDistance = (cfg and cfg.Distance) or 12
    return prompt
end

local function updatePrompts(proxy: BasePart, buildCfg, destroyCfg)
    local boardPrompt = proxy:FindFirstChildOfClass("ProximityPrompt")
    if boardPrompt then
        boardPrompt.KeyboardKeyCode = (buildCfg and buildCfg.KeyCode) or DEFAULT.KeyCode
        boardPrompt.HoldDuration = (buildCfg and buildCfg.Hold) or DEFAULT.Hold
        boardPrompt.MaxActivationDistance = (buildCfg and buildCfg.Distance) or DEFAULT.Distance
    end
    local N, current = computeQuota(proxy, getCfg(buildCfg))
    local kickPrompt = ensureKickPrompt(proxy, destroyCfg)
    -- Show only one prompt at a time:
    -- - Board Up when not fully sealed (current < N)
    -- - Kick only when fully sealed (current == N)
    local showKick = (current >= N and N > 0)
    local showBoard = (current < N)
    if boardPrompt then boardPrompt.Enabled = showBoard end
    kickPrompt.Enabled = showKick
end

local function countChildren(folder)
    local n = 0
    for _, _ in ipairs(folder:GetChildren()) do n += 1 end
    return n
end

-- per-proxy per-player last time stamp to enforce hold build time
local lastAt: { [Instance]: { [number]: number } } = {}

local function placeBoard(player: Player, proxy: BasePart, cfg, destroyCfg)
    if not player or not player.Parent then return end
    cfg = getCfg(cfg)
    local minPerMinute = math.max(cfg.MaxPerMinute or 0, math.floor(60 / math.max(0.05, cfg.Hold)) + 5)
    if not RateLimiter.Allow(player, "BOARDUP", minPerMinute) then return end

    local char = player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not (hrp and hrp:IsA("BasePart")) then return end
    local dist = (hrp.Position - proxy.Position).Magnitude
    if dist > (cfg.Distance + 2) then return end

    -- opening dimensions
    local axis = proxy:GetAttribute("Axis") or "x"
    local boards = proxy:FindFirstChild("Boards")
    if not boards then boards = Instance.new("Folder"); boards.Name = "Boards"; boards.Parent = proxy end

    local length = (axis == "x") and proxy.Size.X or proxy.Size.Z
    local height = proxy.Size.Y
    if length <= 0.1 or height <= 0.1 then return end

    local N, current = computeQuota(proxy, cfg)
    -- Enforce that each plank requires at least Hold seconds of continuous holding
    lastAt[proxy] = lastAt[proxy] or {}
    local now = os.clock()
    local last = lastAt[proxy][player.UserId] or 0
    if now - last < cfg.Hold - 1e-3 then
        return
    end
    lastAt[proxy][player.UserId] = now
    if current >= N then
        setPromptEnabled(proxy, false)
        return
    end

    local slotW = length / N
    local idx = current -- 0-based
    local offsetAlong = -length * 0.5 + (idx + 0.5) * slotW

    local plank = Instance.new("Part")
    plank.Anchored = true
    plank.CanCollide = true
    plank.Material = cfg.Material
    plank.Color = cfg.Color
    plank.Name = string.format("Board_%d", idx + 1)
    if axis == "x" then
        plank.Size = Vector3.new(slotW, height, cfg.PlankThickness)
        plank.CFrame = proxy.CFrame * CFrame.new(offsetAlong, 0, 0)
    else
        plank.Size = Vector3.new(cfg.PlankThickness, height, slotW)
        plank.CFrame = proxy.CFrame * CFrame.new(0, 0, offsetAlong)
    end
    plank.Parent = boards

    if idx + 1 >= N then setPromptEnabled(proxy, false) end
    updatePrompts(proxy, cfg, destroyCfg)
end

-- Knock down one random board with fun effects
local lastKick: { [Instance]: { [number]: number } } = {}

local function kickBoard(player: Player, proxy: BasePart, cfg, destroyCfg, strong: boolean?)
    cfg = getCfg(cfg)
    destroyCfg = destroyCfg or {}
    local perMinute = (destroyCfg.MaxPerMinute or 60)
    if not RateLimiter.Allow(player, "BOARDKICK", perMinute) then return end
    -- Cooldown per opening per player
    local cd = destroyCfg.Cooldown or 0.25
    lastKick[proxy] = lastKick[proxy] or {}
    local now = os.clock()
    local last = lastKick[proxy][player.UserId] or 0
    if now - last < cd then return end
    lastKick[proxy][player.UserId] = now
    -- distance validation
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not (hrp and hrp:IsA("BasePart")) then return end
    local dist = (hrp.Position - proxy.Position).Magnitude
    if dist > ((destroyCfg.Distance or 12) + 2) then return end

    local boards = proxy:FindFirstChild("Boards")
    if not boards then return end
    local children = boards:GetChildren()
    if #children == 0 then return end

    local toBreak = 1
    if strong then
        toBreak = math.min(destroyCfg.StrongBreakMax or 4, math.max(1, math.random(2, 3)))
    elseif math.random() < (destroyCfg.DoubleBreakChance or 0) then
        toBreak = 2
    end

    local eventsOk, Events = pcall(function() return require(game.ReplicatedStorage.Net.Events) end)
    local Debris = game:GetService("Debris")

    for i = 1, toBreak do
        local list = boards:GetChildren()
        if #list == 0 then break end
        local pick = list[math.random(1, #list)]
        if pick and pick:IsA("BasePart") then
            if eventsOk and Events and Events.BoardFX then
                Events.BoardFX:FireAllClients({ kind = "Kick", pos = pick.Position, mag = (destroyCfg.Shake and destroyCfg.Shake.Mag) or 0.4, dur = (destroyCfg.Shake and destroyCfg.Shake.Duration) or 0.1 })
            end
            pick.Parent = workspace
            pick.CanCollide = false
            pick.Anchored = false
            pick.AssemblyLinearVelocity = Vector3.new((math.random()-0.5)*28, 18 + math.random()*10, (math.random()-0.5)*28)
            pick.AssemblyAngularVelocity = Vector3.new(math.random(), math.random(), math.random()) * 8
            Debris:AddItem(pick, 1.6)
        end
    end

    updatePrompts(proxy, cfg, destroyCfg)
end

function BoardUpService.Attach(model: Model, cfg, destroyCfg)
    if not (model and model.Parent) then return end
    local openings = model:FindFirstChild("Openings")
    if not openings then return end

    -- Hook remote for hold-to-board behavior
    local eventsOk, Events = pcall(function() return require(game.ReplicatedStorage.Net.Events) end)
        if eventsOk and Events then
            Events.BoardUp.OnServerEvent:Connect(function(player, proxy)
                if typeof(proxy) == "Instance" and proxy:IsDescendantOf(openings) then
                placeBoard(player, proxy, cfg, destroyCfg)
                end
            end)
            if Events.BoardKick then
                Events.BoardKick.OnServerEvent:Connect(function(player, proxy, strong)
                    if typeof(proxy) == "Instance" and proxy:IsDescendantOf(openings) then
                        kickBoard(player, proxy, cfg, destroyCfg, strong == true)
                    end
                end)
            end
        end

    for _, proxy in ipairs(openings:GetChildren()) do
        if proxy:IsA("BasePart") then
            local prompt = proxy:FindFirstChildOfClass("ProximityPrompt")
            if prompt then
                -- Primary board prompt is already on the proxy (created in generator)
                -- Configure it and add fallback Triggered handler
                prompt.ActionText = "Board Up"
                prompt.RequiresLineOfSight = false
                prompt.Triggered:Connect(function(player)
                    placeBoard(player, proxy, cfg, destroyCfg)
                end)
            end
            -- Kick prompt
            local kp = ensureKickPrompt(proxy, destroyCfg)
            kp.Triggered:Connect(function(player)
                kickBoard(player, proxy, cfg, destroyCfg)
            end)
            updatePrompts(proxy, cfg, destroyCfg)
        end
    end
end

return BoardUpService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="24">
        <Properties>
          <string name="Name">ConstructionService</string>
          <string name="Source"><![CDATA[-- ConstructionService: handles server-side construction generation
-- Responsibility: listen for build requests and spawn a simple defensive box

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local Events
do
    local ok, mod = pcall(function() return require(ReplicatedStorage:WaitForChild("Net"):WaitForChild("Events")) end)
    if ok and mod then Events = mod else
        -- Fallback to Remotes folder if Net.Events is unavailable
        local folder = ReplicatedStorage:FindFirstChild("Remotes") or Instance.new("Folder")
        folder.Name = "Remotes"
        folder.Parent = ReplicatedStorage
        local function ensure(name, className)
            local obj = folder:FindFirstChild(name)
            if not obj then obj = Instance.new(className) obj.Name = name obj.Parent = folder end
            return obj
        end
        Events = { Construction = ensure("ConstructionRequest", "RemoteEvent") }
    end
end

local ConstructionService = {}

-- Simple, configurable defaults (kept local to avoid broad config edits)
local DEFAULTS = {
    wallHeight = 12,
    wallThickness = 2,
    boxInnerSize = 24, -- inner square size between opposite walls
    color = Color3.fromRGB(120, 170, 120),
    cooldownSec = 3,
}

-- Basic per-player cooldown
local lastRequestAt: { [number]: number } = {}

local function withinCooldown(player: Player)
    local now = os.clock()
    local last = lastRequestAt[player.UserId] or 0
    if now - last < DEFAULTS.cooldownSec then return true end
    lastRequestAt[player.UserId] = now
    return false
end

local function getGreenSpawn()
    local spawn = Workspace:FindFirstChild("GreenSpawn")
    if spawn and spawn:IsA("BasePart") then return spawn end
    -- Accept SpawnLocation too
    if spawn and spawn:IsA("SpawnLocation") then return spawn end
    return nil
end

local function clearOld()
    for _, name in ipairs({"DefenseWalls", "GeneratedBuilding"}) do
        local container = Workspace:FindFirstChild(name)
        if container then container:Destroy() end
    end
end

local function makeWall(name: string, size: Vector3, cframe: CFrame, color: Color3)
    local p = Instance.new("Part")
    p.Name = name
    p.Anchored = true
    p.CanCollide = true
    p.TopSurface = Enum.SurfaceType.Smooth
    p.BottomSurface = Enum.SurfaceType.Smooth
    p.Size = size
    p.CFrame = cframe
    p.Color = color
    return p
end

local function buildProceduralAt(origin: CFrame)
    clearOld()

    -- Determine floor Y offset
    local baseplate = Workspace:FindFirstChild("Baseplate")
    local groundY = baseplate and baseplate.Position.Y + (baseplate.Size.Y * 0.5) or 0

    local originOnGround = CFrame.new(origin.Position.X, groundY, origin.Position.Z)

    -- Load config
    local cfgLoaderOk, Loader = pcall(function()
        return require(ReplicatedStorage.Shared.ConfigLoader)
    end)
    local sharedCfg = (cfgLoaderOk and Loader and Loader.Load("ConstructionService")) or nil
    local buildCfg = sharedCfg and sharedCfg.CONSTRUCTION or nil
    if not buildCfg then
        warn("[ConstructionService] CONSTRUCTION config missing; using ad-hoc defaults")
        buildCfg = {
            Seed = 1337,
            Footprint = { Width = 96, Length = 72 },
            Floors = 1,
            WallHeight = 16.8,
            WallThickness = 2,
            CorridorWidth = 12,
            Room = { MinSize = { Width = 16, Length = 14 }, MaxSize = { Width = 34, Length = 28 } },
            Door = { Width = 10, MinWidth = 12, Height = 9, Clearance = 3, MinSpacing = 18 },
            ExteriorDoors = 2,
            Window = { Width = 6, Height = 5, SillHeight = 4, Spacing = 8, InsetFromCorner = 4 },
            Colors = { Walls = Color3.fromRGB(150,150,150), InteriorWalls = Color3.fromRGB(150,150,150), Corridors = Color3.fromRGB(170,170,170), Rooms = Color3.fromRGB(210,210,210), Floor = Color3.fromRGB(140,110,80), Roof = Color3.fromRGB(255,255,255) },
            Materials = { Walls = Enum.Material.Concrete, InteriorWalls = Enum.Material.Concrete, Floor = Enum.Material.Wood, Roof = Enum.Material.SmoothPlastic },
            GenerateFloors = false,
            GenerateFloorSlab = true,
            GenerateRoof = true,
            Slab = { FloorThickness = 1, RoofThickness = 1, Extend = 0, FloorOffset = 0.5 },
            Debug = { Print = true, VisualizeRects = false, Randomize = true },
            BOARDUP = { PlankWidth = 1.5, PlankThickness = 0.2, Hold = 0.2, MaxBoardsPerOpening = 24, MaxPerMinute = 30, KeyCode = Enum.KeyCode.E, Distance = 12, Material = Enum.Material.WoodPlanks, Color = Color3.fromRGB(155,120,80) },
            DESTROY = { KeyCode = Enum.KeyCode.Q, Cooldown = 0.25, MaxPerMinute = 60, Distance = 12, DoubleBreakChance = 0.25, StrongBreakMax = 4, Shake = { Mag = 0.5, Duration = 0.12 } },
        }
    end

    -- Call generator
    local ok, gen = pcall(function()
        return require(ReplicatedStorage:WaitForChild("Construction"):WaitForChild("Generator"))
    end)
    if not ok or not gen then
        warn("[ConstructionService] Generator module not found")
        return
    end
    -- Shallow clone config so we can override Seed per build without mutating shared config
    local runCfg = table.clone(buildCfg)
    -- Randomize per build (unless Debug.Randomize == false)
    local salt = math.floor((os.clock() * 1000) % 1e9)
    local shouldRandomize = true
    if buildCfg.Debug and buildCfg.Debug.Randomize == false then
        shouldRandomize = false
    end
    runCfg.Seed = (buildCfg.Seed or 0) + (shouldRandomize and salt or 0)

    local model, meta = gen.Generate(originOnGround, runCfg)
    if model then
        print("[ConstructionService] Generated procedural building")
    end

    -- Send ASCII minimap to clients for debugging/feedback
    pcall(function()
        local walls = model and model:FindFirstChild("Walls")
        if not walls then return end
        local parts = walls:GetChildren()
        if #parts == 0 then return end
        local minX, maxX, minZ, maxZ = math.huge, -math.huge, math.huge, -math.huge
        for _, p in ipairs(parts) do
            if p:IsA("BasePart") then
                local px, pz = p.Position.X, p.Position.Z
                local sx, sz = p.Size.X, p.Size.Z
                minX = math.min(minX, px - sx * 0.5)
                maxX = math.max(maxX, px + sx * 0.5)
                minZ = math.min(minZ, pz - sz * 0.5)
                maxZ = math.max(maxZ, pz + sz * 0.5)
            end
        end
        local spanX = math.max(1, maxX - minX)
        local spanZ = math.max(1, maxZ - minZ)
        local targetCols = 60
        local cell = math.max(1, math.max(spanX, spanZ) / targetCols)
        local cols = math.floor(spanX / cell + 0.5)
        local rows = math.floor(spanZ / cell + 0.5)
        local grid = {}
        for r = 1, rows do
            local row = table.create(cols, " ")
            grid[r] = row
        end
        for _, p in ipairs(parts) do
            if p:IsA("BasePart") then
                local x0 = p.Position.X - p.Size.X * 0.5
                local x1 = p.Position.X + p.Size.X * 0.5
                local z0 = p.Position.Z - p.Size.Z * 0.5
                local z1 = p.Position.Z + p.Size.Z * 0.5
                local c0 = math.max(1, math.floor((x0 - minX) / cell) + 1)
                local c1 = math.min(cols, math.floor((x1 - minX) / cell) + 1)
                local r0 = math.max(1, math.floor((z0 - minZ) / cell) + 1)
                local r1 = math.min(rows, math.floor((z1 - minZ) / cell) + 1)
                for r = r0, r1 do
                    local row = grid[r]
                    for c = c0, c1 do
                        row[c] = "#"
                    end
                end
            end
        end
        local lines = {}
        for r = rows, 1, -1 do
            lines[#lines + 1] = table.concat(grid[r])
        end
        local mapText = table.concat(lines, "\n")
        print("[Construction Minimap]\n" .. mapText)
    end)

    -- Move Green spawn to the largest room center (on floor)
    if meta and meta.largestRoomCenter and meta.floorTopY then
        local spawn = getGreenSpawn()
        if spawn and spawn:IsA("BasePart") then
            local pos = meta.largestRoomCenter
            local y = meta.floorTopY + (spawn.Size.Y * 0.5)
            spawn.CFrame = CFrame.new(Vector3.new(pos.X, y, pos.Z))
        end
    end

    -- Lower grass terrain just under the building floor level within the building bounds
    pcall(function()
        if not (model and meta and meta.floorTopY) then return end
        local terrain = Workspace.Terrain
        local bboxCF, bboxSize = model:GetBoundingBox()
        local pad = 6
        local extentX = bboxSize.X + pad
        local extentZ = bboxSize.Z + pad
        -- Set grass top below the original floor base (ignoring visual floor offset)
        local baseY = meta.floorBaseY or meta.floorTopY
        local targetTop = baseY - 2

        -- Carve out existing terrain from well below up to just below the floor within bounds
        local airHeight = 128
        local airCF = CFrame.new(bboxCF.Position.X, targetTop - airHeight * 0.5, bboxCF.Position.Z)
        terrain:FillBlock(airCF, Vector3.new(extentX, airHeight, extentZ), Enum.Material.Air)

        -- Refill with grass up to slightly below the floor to avoid z-fighting
        local grassTop = targetTop -- targetTop already includes a 2-stud offset below the floor
        local grassThick = 32
        local grassCF = CFrame.new(bboxCF.Position.X, grassTop - grassThick * 0.5, bboxCF.Position.Z)
        terrain:FillBlock(grassCF, Vector3.new(extentX, grassThick, extentZ), Enum.Material.Grass)
    end)

    -- Attach board-up interactions
    pcall(function()
        local BoardUp = require(script.Parent:WaitForChild("BoardUpService"))
        BoardUp.Attach(model, buildCfg.BOARDUP or {}, buildCfg.DESTROY or {})
    end)
end

local function handleConstructionRequest(player: Player)
    -- Validate player exists and is in game
    if not player or not player.Parent then return end
    if withinCooldown(player) then
        warn(string.format("[ConstructionService] Rate limited: %s", player.Name))
        return
    end

    local greenSpawn = getGreenSpawn()
    if not greenSpawn then
        warn("[ConstructionService] GreenSpawn not found; cannot build")
        return
    end

    -- Build procedural structure near the green team spawn
    buildProceduralAt(greenSpawn.CFrame)
    print(string.format("[ConstructionService] Built procedural building near Green spawn (by %s)", player.Name))
end

function ConstructionService.Init()
    -- Resolve remote robustly
    local remote = Events and Events.Construction or nil
    if not remote then
        local remotesFolder = ReplicatedStorage:FindFirstChild("Remotes") or ReplicatedStorage:WaitForChild("Remotes", 10)
        if remotesFolder then
            remote = remotesFolder:FindFirstChild("ConstructionRequest") or remotesFolder:WaitForChild("ConstructionRequest", 10)
        end
    end

    if not remote then
        warn("[ConstructionService] ConstructionRequest remote not found; cannot initialize")
        return
    end

    -- Connect remote
    remote.OnServerEvent:Connect(function(player)
        print(string.format("[ConstructionService] Request received from %s", player and player.Name or "?"))
        -- No payload needed yet
        handleConstructionRequest(player)
    end)

    -- Cleanup cooldown table when players leave
    Players.PlayerRemoving:Connect(function(plr)
        lastRequestAt[plr.UserId] = nil
    end)

    print("[ConstructionService] Initialized and listening for ConstructionRequest")
end

-- Auto-init if required directly
ConstructionService.Init()

return ConstructionService
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="ModuleScript" referent="25">
      <Properties>
        <string name="Name">ConstructionService</string>
        <string name="Source"><![CDATA[-- Compatibility shim so scripts requiring ServerScriptService.ConstructionService can find the module
return require(script.Parent.Construction.ConstructionService)

]]></string>
      </Properties>
    </Item>
    <Item class="Folder" referent="26">
      <Properties>
        <string name="Name">Debug</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="27">
      <Properties>
        <string name="Name">Gameplay</string>
      </Properties>
      <Item class="ModuleScript" referent="28">
        <Properties>
          <string name="Name">HitRegService</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function getEvents()
    -- TODO: ISSUE #8 - Code Duplication: Remote event creation logic duplicated across multiple files
    -- Should be centralized in a shared utility module
    local net = ReplicatedStorage:FindFirstChild("Net")
    if net and net:FindFirstChild("Events") then
        local ok, mod = pcall(require, net.Events)
        if ok and mod then return mod end
    end
    local folder = ReplicatedStorage:FindFirstChild("Remotes")
    if not folder then
        folder = Instance.new("Folder"); folder.Name = "Remotes"; folder.Parent = ReplicatedStorage
    end
    local function ensure(name, class)
        local obj = folder:FindFirstChild(name)
        if not obj then obj = Instance.new(class); obj.Name = name; obj.Parent = folder end
        return obj
    end
    return {
        FireWeapon = ensure("FireWeapon", "RemoteEvent"),
        HitConfirm = ensure("HitConfirm", "RemoteEvent"),
    }
end

local Events = getEvents()
local RateLimiter = require(game.ServerScriptService.AntiCheat.RateLimiter)

-- Simple config to avoid ConfigLoader dependency
local Config = {
    WEAPONS = {
        RateLimit = 120,  -- requests per minute
    },
}

-- Input validation utility functions
local function validateVector3(vec, maxMagnitude)
    if typeof(vec) ~= "Vector3" then return false end
    if vec.X ~= vec.X or vec.Y ~= vec.Y or vec.Z ~= vec.Z then return false end -- Check for NaN
    if maxMagnitude and vec.Magnitude > maxMagnitude then return false end
    return true
end

local function validatePlayerState(player)
    if not player then return false, "Player is nil" end
    if not player.Parent then return false, "Player is not in game" end
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character.Humanoid
        if humanoid.Health <= 0 then return false, "Player is dead" end
    end
    return true
end

local function validateWeaponFirePayload(payload)
    if not payload then return false, "Payload is nil" end
    if typeof(payload) ~= "table" then return false, "Payload is not a table" end

    if not payload.origin or not payload.dir or not payload.weaponName then
        return false, "Missing required fields: origin, dir, or weaponName"
    end

    if not validateVector3(payload.origin, 1000) then
        return false, "Invalid origin vector"
    end

    if not validateVector3(payload.dir, 10) then
        return false, "Invalid direction vector"
    end

    if typeof(payload.weaponName) ~= "string" then
        return false, "Invalid weapon name type"
    end

    return true
end

-- Store event connections to prevent memory leaks
local connections = {}

-- Clean up function to disconnect all stored connections
local function cleanupConnections()
    for _, connection in ipairs(connections) do
        if connection.Connected then
            connection:Disconnect()
        end
    end
    connections = {}
end

-- Store the connection to prevent memory leaks
table.insert(connections, Events.FireWeapon.OnServerEvent:Connect(function(plr, payload)
    -- Comprehensive input validation and error handling
    local isPlayerValid, playerError = validatePlayerState(plr)
    if not isPlayerValid then
        warn(string.format("[HitRegService] Invalid player state: %s (UserId: %s)", playerError, plr.UserId or "unknown"))
        return
    end

    local isPayloadValid, payloadError = validateWeaponFirePayload(payload)
    if not isPayloadValid then
        warn(string.format("[HitRegService] Invalid payload: %s (UserId: %s)", payloadError, plr.UserId))
        Events.HitConfirm:FireClient(plr, { ok = false, error = "Invalid request" })
        return
    end

    -- Rate limiting check
    if not RateLimiter.Allow(plr, "FireWeapon", Config.WEAPONS.RateLimit or 120) then
        Events.HitConfirm:FireClient(plr, { ok = false, error = "Rate limit exceeded" })
        return
    end

    -- Perform raycast with error handling
    local success, result = pcall(function()
        return workspace:Raycast(payload.origin, payload.dir)
    end)

    if not success then
        warn(string.format("[HitRegService] Raycast failed: %s (UserId: %s)", result, plr.UserId))
        Events.HitConfirm:FireClient(plr, { ok = false, error = "Raycast failed" })
        return
    end

    -- Process hit result
    if result then
        -- TODO: Add hit processing logic (damage, destruction, etc.)
        Events.HitConfirm:FireClient(plr, { ok = true, hit = true })
    else
        Events.HitConfirm:FireClient(plr, { ok = true, hit = false })
    end
end))

-- Cleanup on game shutdown
game:BindToClose(cleanupConnections)
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="29">
        <Properties>
          <string name="Name">ObjectiveService</string>
          <string name="Source"><![CDATA[-- Objective: spawn, pickup, steal, carry-follow, deliver at Green spawn

local ServerStorage = game:GetService("ServerStorage")
local InsertService = game:GetService("InsertService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Simple config to avoid ConfigLoader dependency
local Config = {
    OBJECTIVE = {
        Size = Vector3.new(3, 3, 3),
        Color = Color3.fromRGB(255, 255, 0),
        SpawnDistance = 30,
        TimeLimit = 60,
        -- Asset id for briefcase model
        ModelAssetId = 530795465,
    },
    EXTRACT = {
        Size = Vector3.new(10, 1, 10),
        Color = Color3.fromRGB(120, 200, 255),
    },
}

-- Store event connections to prevent memory leaks
local connections = {}

-- Clean up function to disconnect all stored connections
local function cleanupConnections()
    for _, connection in ipairs(connections) do
        if connection.Connected then
            connection:Disconnect()
        end
    end
    connections = {}
end

local ObjectiveService = {}
local objectiveModel = nil -- Model or BasePart root for the objective
local objectivePart = nil -- BasePart used for prompt/effects (PrimaryPart or first BasePart)
local objectiveUsingFallback = false -- True if using simple cube instead of asset
local carrier = nil
local extractZone = nil
local roundStartTime = nil
local redSpawnPosition = nil
local greenSpawnPosition = nil
local followConnection = nil
local objectivePrompt = nil

local function getOrCreatePart(name, size, position, color)
    local p = workspace:FindFirstChild(name)
    if not p then
        p = Instance.new("Part")
        p.Name = name
        p.Anchored = true
        p.CanCollide = false
        p.TopSurface = Enum.SurfaceType.Smooth
        p.BottomSurface = Enum.SurfaceType.Smooth
        p.Parent = workspace
    end
    p.Size = size
    p.Position = position
    if color then p.Color = color end
    return p
end

-- Resolve the base part for a model (PrimaryPart or first BasePart descendant)
local function getModelBasePart(inst: Instance): BasePart?
    if not inst then return nil end
    if inst:IsA("Model") then
        if inst.PrimaryPart then return inst.PrimaryPart end
        for _, d in ipairs(inst:GetDescendants()) do
            if d:IsA("BasePart") then return d end
        end
    elseif inst:IsA("Tool") then
        local h = inst:FindFirstChild("Handle")
        if h and h:IsA("BasePart") then return h end
        for _, d in ipairs(inst:GetDescendants()) do
            if d.Name == "Handle" and d:IsA("BasePart") then return d end
            if d:IsA("BasePart") then return d end
        end
    elseif inst:IsA("BasePart") then
        return inst
    end
    return nil
end

-- Anchor/collide settings across model or part
local function setObjectivePhysics(inst: Instance, anchored: boolean, canCollide: boolean)
    if not inst then return end
    if inst:IsA("BasePart") then
        inst.Anchored = anchored
        inst.CanCollide = canCollide
    elseif inst:IsA("Model") or inst:IsA("Tool") then
        for _, d in ipairs(inst:GetDescendants()) do
            if d:IsA("BasePart") then
                d.Anchored = anchored
                d.CanCollide = canCollide
            end
        end
    end
end

-- Move helpers for model/part
local function setObjectiveCFrame(inst: Instance, cf: CFrame)
    if not inst then return end
    if inst:IsA("BasePart") then
        inst.CFrame = cf
    elseif inst:IsA("Model") then
        inst:PivotTo(cf)
    elseif inst:IsA("Tool") then
        local bp = getModelBasePart(inst)
        if bp then bp.CFrame = cf end
    end
end

local function setObjectivePosition(inst: Instance, pos: Vector3)
    if not inst then return end
    if inst:IsA("BasePart") then
        inst.Position = pos
    elseif inst:IsA("Model") then
        local bp = getModelBasePart(inst)
        if bp then
            local current = bp.CFrame
            setObjectiveCFrame(inst, CFrame.new(pos) * (current - current.Position))
        else
            inst:PivotTo(CFrame.new(pos))
        end
    elseif inst:IsA("Tool") then
        local bp = getModelBasePart(inst)
        if bp then bp.Position = pos end
    end
end

-- Toggle all visual effects under the objective (Lights, Beams, ParticleEmitters)
local function setEffectsEnabled(inst: Instance, enabled: boolean)
    if not inst then return end
    for _, d in ipairs(inst:GetDescendants()) do
        if d:IsA("ParticleEmitter") then d.Enabled = enabled end
        if d:IsA("Beam") then d.Enabled = enabled end
        if d:IsA("Light") then d.Enabled = enabled end
    end
end

-- Load the briefcase model or fallback to a simple part
local function createObjectiveInstance(name: string, size: Vector3, position: Vector3, color: Color3)
    -- 1) Prefer a prebundled model placed in the experience for reliability
    local function findBundled()
        local modelName = (Config.OBJECTIVE and Config.OBJECTIVE.ModelName) or "Briefcase"
        local idName = tostring((Config.OBJECTIVE and Config.OBJECTIVE.ModelAssetId) or "")
        local locations = {
            ServerStorage:FindFirstChild("Assets"),
            ReplicatedStorage:FindFirstChild("Assets"),
            ServerStorage,
            ReplicatedStorage,
        }
        local function resolveCandidate(inst)
            if not inst then return nil end
            if inst:IsA("Model") or inst:IsA("BasePart") or inst:IsA("Tool") then return inst end
            if inst:IsA("Folder") then
                for _, child in ipairs(inst:GetChildren()) do
                    if child:IsA("Model") or child:IsA("BasePart") or child:IsA("Tool") then
                        return child
                    end
                end
            end
            return nil
        end
        for _, loc in ipairs(locations) do
            if loc then
                -- Try by friendly name then by numeric ID filename
                local candidates = {}
                table.insert(candidates, modelName)
                if idName ~= "" then table.insert(candidates, idName) end
                table.insert(candidates, modelName .. ".rbxm")
                table.insert(candidates, modelName .. ".rbxmx")
                for _, nm in ipairs(candidates) do
                    local inst = loc:FindFirstChild(nm)
                    local resolved = resolveCandidate(inst)
                    if resolved then return resolved end
                end
                -- Fallback: first usable child in Assets folder
                for _, child in ipairs(loc:GetChildren()) do
                    local resolved = resolveCandidate(child)
                    if resolved then
                        print("[ObjectiveService] Using first available asset in", loc:GetFullName(), "->", child.Name)
                        return resolved
                    end
                end
            end
        end
        return nil
    end

    -- Try to find bundled asset, allowing a short grace period for Rojo to sync
    -- Debug: list children under ReplicatedStorage/Assets to help diagnose
    do
        local ra = ReplicatedStorage:FindFirstChild("Assets")
        if ra then
            local names = {}
            for _, ch in ipairs(ra:GetChildren()) do
                table.insert(names, string.format("%s(%s)", ch.Name, ch.ClassName))
            end
            print("[ObjectiveService] ReplicatedStorage.Assets children:", table.concat(names, ", "))
        else
            print("[ObjectiveService] ReplicatedStorage.Assets not found at spawn time")
        end
    end

    local bundled = findBundled()
    if not bundled then
        print("[ObjectiveService] No bundled objective found yet; waiting for Rojo sync...")
        for _ = 1, 20 do -- up to ~5 seconds (20 * 0.25)
            task.wait(0.25)
            bundled = findBundled()
            if bundled then break end
        end
    end
    if bundled then
        local clone = bundled:Clone()
        clone.Name = name
        clone.Parent = workspace
        local bp = getModelBasePart(clone) or (clone:IsA("BasePart") and clone)
        if bp then
            if clone:IsA("Model") then clone:PivotTo(CFrame.new(position)) else bp.Position = position end
            objectiveModel = clone
            objectivePart = bp
            objectiveUsingFallback = false
            setObjectivePhysics(objectiveModel, true, false)
            print("[ObjectiveService] Spawned bundled objective model:", bundled:GetFullName(), "(type:", bundled.ClassName .. ")")
            return objectiveModel
        else
            clone:Destroy()
        end
    end

    print("[ObjectiveService] Bundled asset not found; attempting InsertService as fallback")
    local assetId = Config.OBJECTIVE.ModelAssetId
    local modelInstance: Instance? = nil
    if typeof(assetId) == "number" and assetId > 0 then
        local ok, asset = pcall(function()
            return InsertService:LoadAsset(assetId)
        end)
        if ok and asset and asset:IsA("Model") then
            -- Some assets load as a container Model with children; pick first child if single child
            local children = asset:GetChildren()
            if #children == 1 and children[1]:IsA("Model") then
                modelInstance = children[1]
                modelInstance.Parent = workspace
                asset:Destroy()
            else
                modelInstance = asset
                modelInstance.Parent = workspace
            end
            modelInstance.Name = name
            -- Place near desired position
            local base = getModelBasePart(modelInstance)
            if base then
                modelInstance:PivotTo(CFrame.new(position))
                print("[ObjectiveService] Loaded asset model:", assetId)
            else
                -- No parts? Fallback to simple part
                modelInstance:Destroy()
                modelInstance = nil
            end
        else
            warn("[ObjectiveService] InsertService.LoadAsset failed or returned non-Model for asset:", assetId, ok and (asset and asset.ClassName or "nil") or "pcall failed")
        end
    end

    if modelInstance then
        objectiveModel = modelInstance
        objectivePart = getModelBasePart(modelInstance)
        setObjectivePhysics(objectiveModel, true, false)
        objectiveUsingFallback = false
        return objectiveModel
    else
        -- Fallback: neon box
        objectiveModel = getOrCreatePart(name, size, position, color)
        objectivePart = objectiveModel
        objectiveUsingFallback = true
        print("[ObjectiveService] Using fallback cube for objective")
        return objectiveModel
    end
end

-- Input validation functions
local function validatePlayerState(player)
    if not player then return false, "Player is nil" end
    if not player.Parent then return false, "Player is not in game" end
    return true
end

local function validateObjectiveEventPayload(payload)
    if not payload then return false, "Payload is nil" end
    if typeof(payload) ~= "table" then return false, "Payload is not a table" end

    if not payload.type then
        return false, "Missing required field: type"
    end

    if typeof(payload.type) ~= "string" then
        return false, "Invalid type field"
    end

    local validTypes = { "Pickup", "Drop" }
    local isValidType = false
    for _, validType in ipairs(validTypes) do
        if payload.type == validType then
            isValidType = true
            break
        end
    end

    if not isValidType then
        return false, "Invalid event type: " .. payload.type
    end

    return true
end

-- Get events with error handling
local function getEvents()
    local net = ReplicatedStorage:FindFirstChild("Net")
    if net and net:FindFirstChild("Events") then
        local ok, mod = pcall(require, net.Events)
        if ok and mod then return mod end
    end
    local folder = ReplicatedStorage:FindFirstChild("Remotes")
    if not folder then
        folder = Instance.new("Folder")
        folder.Name = "Remotes"
        folder.Parent = ReplicatedStorage
    end
    local function ensure(name, className)
        local obj = folder:FindFirstChild(name)
        if not obj then
            obj = Instance.new(className)
            obj.Name = name
            obj.Parent = folder
        end
        return obj
    end
    return {
        Objective = ensure("ObjectiveEvent", "RemoteEvent"),
    }
end

local Events = getEvents()

-- Function to get random position away from green spawn
local function clampToBaseplate(pos, objHalfY)
    local base = workspace:FindFirstChild("Baseplate")
    if not base or not base:IsA("BasePart") then
        return pos -- no baseplate to clamp against
    end
    local margin = 5
    local half = base.Size * 0.5
    local minX = base.Position.X - half.X + margin
    local maxX = base.Position.X + half.X - margin
    local minZ = base.Position.Z - half.Z + margin
    local maxZ = base.Position.Z + half.Z - margin
    local yTop = base.Position.Y + half.Y + (objHalfY or 1.5)
    local x = math.clamp(pos.X, minX, maxX)
    local z = math.clamp(pos.Z, minZ, maxZ)
    return Vector3.new(x, yTop, z)
end

local function getRandomObjectivePosition(greenSpawnPos, distance, objSize)
    local angle = math.random() * math.pi * 2
    local x = greenSpawnPos.X + math.cos(angle) * distance
    local z = greenSpawnPos.Z + math.sin(angle) * distance
    local y = greenSpawnPos.Y + (objSize and objSize.Y or 3) * 0.5
    local candidate = Vector3.new(x, y, z)
    return clampToBaseplate(candidate, (objSize and objSize.Y or 3) * 0.5)
end

local function stopFollowing()
    if followConnection and followConnection.Connected then
        followConnection:Disconnect()
    end
    followConnection = nil
end

local function startFollowing(plr)
    stopFollowing()
    if not objectiveModel or not plr or not plr.Character then return end
    local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    setObjectivePhysics(objectiveModel, true, false)
    local offset = Vector3.new(0, 4, 0)
    followConnection = RunService.Heartbeat:Connect(function()
        if not carrier or not carrier.Character or not carrier.Character:FindFirstChild("HumanoidRootPart") then
            stopFollowing()
            return
        end
        local cframe = carrier.Character.HumanoidRootPart.CFrame + offset
        setObjectiveCFrame(objectiveModel, cframe)
    end)
end

function ObjectiveService.StartRound(redSpawnPos)
    -- Stop following and clear carrier from previous round
    stopFollowing()
    carrier = nil

    -- Destroy existing objective model
    if objectiveModel then
        objectiveModel:Destroy()
        objectiveModel = nil
    end
    objectivePart = nil
    objectivePrompt = nil

    -- Set spawn positions for this round
    redSpawnPosition = redSpawnPos
    roundStartTime = nil  -- Don't start timer yet, wait for StartTimer()

    print("[ObjectiveService] StartRound called with RedSpawn:", redSpawnPos)

    -- Find green spawn position (should be at (200, 1.5, 200))
    local greenSpawn = workspace:FindFirstChild("GreenSpawn")
    local greenPos = greenSpawn and greenSpawn.Position or Vector3.new(200, 1.5, 200)
    greenSpawnPosition = greenPos

    -- Calculate random objective position
    local objSize = Config.OBJECTIVE.Size or Vector3.new(3,3,3)
    local objectivePos = getRandomObjectivePosition(greenPos, Config.OBJECTIVE.SpawnDistance, objSize)

    -- positions computed for spawn

    -- Create objective - prefer model asset (briefcase), fallback to bright box
    local objColor = Config.OBJECTIVE.Color or Color3.fromRGB(255, 255, 0)
    createObjectiveInstance("ObjectiveBox", objSize, objectivePos, objColor)
    
    -- Make it very visible (only override material if using fallback cube)
    if objectiveUsingFallback and objectivePart and objectivePart:IsA("BasePart") then
        objectivePart.Material = Enum.Material.Neon
        objectivePart.BrickColor = BrickColor.new("Bright yellow")
    end

    -- Make it glow and more visible
    local glow = Instance.new("PointLight")
    glow.Color = Color3.fromRGB(255, 255, 0)
    glow.Brightness = 3
    glow.Range = 25
    glow.Parent = objectivePart or objectiveModel

    -- Add a pulsing effect
    local tweenService = game:GetService("TweenService")
    local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
    local tween = tweenService:Create(objectivePart or objectiveModel, tweenInfo, {Transparency = 0.2})
    tween:Play()

    -- Add surface light for even more visibility
    local surfaceLight = Instance.new("SurfaceLight")
    surfaceLight.Color = Color3.fromRGB(255, 255, 0)
    surfaceLight.Brightness = 5
    surfaceLight.Range = 15
    surfaceLight.Parent = objectivePart or objectiveModel


    -- Add a beam effect to make it even more visible
    local beam = Instance.new("Beam")
    beam.Color = ColorSequence.new(Color3.fromRGB(255, 255, 0))
    beam.Width0 = 2
    beam.Width1 = 2
    beam.Parent = objectivePart or objectiveModel

    -- Add some particle effects
    local particles = Instance.new("ParticleEmitter")
    particles.Color = ColorSequence.new(Color3.fromRGB(255, 255, 0))
    particles.Size = NumberSequence.new(0.5, 1)
    particles.Lifetime = NumberRange.new(2, 4)
    particles.Rate = 20
    particles.Speed = NumberRange.new(2, 5)
    particles.Parent = objectivePart or objectiveModel


    -- Add a simple ProximityPrompt to allow pickup (Red team only)
    local promptParent = objectivePart or objectiveModel
    if promptParent:FindFirstChild("PickupPrompt") then
        promptParent.PickupPrompt:Destroy()
    end
    objectivePrompt = Instance.new("ProximityPrompt")
    objectivePrompt.Name = "PickupPrompt"
    objectivePrompt.ActionText = "Pick Up"
    objectivePrompt.ObjectText = "Objective"
    objectivePrompt.HoldDuration = 0.25
    objectivePrompt.RequiresLineOfSight = false
    objectivePrompt.MaxActivationDistance = 12
    objectivePrompt.Parent = promptParent

    table.insert(connections, objectivePrompt.Triggered:Connect(function(plr)
        if not plr or not plr.Team then return end

        -- If current carrier uses the prompt, drop it
        if carrier == plr then
            stopFollowing()

            -- Drop objective at player's current position (not random spawn)
            if objectiveModel and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local dropPos = plr.Character.HumanoidRootPart.Position + Vector3.new(0, 2, 3)
                setObjectivePosition(objectiveModel, dropPos)
                setObjectivePhysics(objectiveModel, true, false)
                if objectivePart and objectivePart:IsA("BasePart") then
                    objectivePart.Transparency = 0
                end
                if objectivePrompt then objectivePrompt.ActionText = "Pick Up" end
                setEffectsEnabled(objectiveModel, true)
            end

            carrier = nil
            Events.Objective:FireAllClients({ type = "Dropped", by = plr.UserId })
            return
        end

        if not carrier then
            -- Ground pickup: allow both teams
            carrier = plr
            print("[ObjectiveService] Player", plr.Name, "picked up objective. Team:", plr.Team and plr.Team.Name or "No team")
            startFollowing(plr)
            objectivePrompt.ActionText = "Drop/Steal"
            Events.Objective:FireAllClients({ type = "Carry", by = plr.UserId })
            return
        end

        -- Steal: allow opposing team to take from current carrier
        if carrier and carrier.Team and plr.Team and carrier.Team ~= plr.Team then
            local prev = carrier
            carrier = plr
            startFollowing(plr)
            objectivePrompt.ActionText = "Drop/Steal"
            Events.Objective:FireAllClients({ type = "Stolen", from = prev.UserId, by = plr.UserId })
        end
    end))

    -- Broadcast objective spawn to all clients (include Green spawn for guidance)
    Events.Objective:FireAllClients({
        type = "ObjectiveSpawned",
        position = objectivePos,
        timeLimit = Config.OBJECTIVE.TimeLimit,
        greenSpawn = greenPos,
        redSpawn = redSpawnPos
    })
end

function ObjectiveService.GetTimeRemaining()
    if not roundStartTime then return Config.OBJECTIVE.TimeLimit end  -- Return full time if not started
    local elapsed = os.clock() - roundStartTime
    return math.max(0, Config.OBJECTIVE.TimeLimit - elapsed)
end

function ObjectiveService.Tick()
    print("[ObjectiveService] Tick called - Carrier:", carrier and carrier.Name or "nil", "RedSpawn:", redSpawnPosition and "set" or "nil")

    -- Check time limit first
    local timeRemaining = ObjectiveService.GetTimeRemaining()
    if roundStartTime and timeRemaining <= 0 then  -- Only check time if timer started
        print("[ObjectiveService] Time up! Returning DefenseWin")
        Events.Objective:FireAllClients({ type = "TimeUp", winner = "Defense" })
        return "DefenseWin"
    end

    -- Check if red player with objective is at red spawn
    if carrier and redSpawnPosition then
        print("[ObjectiveService] Carrier exists:", carrier.Name, "Team:", carrier.Team and carrier.Team.Name or "No team")

        -- Check if carrier is still valid
        local isCarrierValid = validatePlayerState(carrier)
        if not isCarrierValid then
            print("[ObjectiveService] Carrier invalid, dropping")
            carrier = nil
            Events.Objective:FireAllClients({ type="Dropped", by=0 })
            return nil
        end

        -- Check if carrier is red team
        if carrier.Team and carrier.Team.Name == "Red" then
            print("[ObjectiveService] Red carrier detected")
            -- Check if carrier's character exists and is at RED spawn (main win condition)
            if carrier.Character and carrier.Character:FindFirstChild("HumanoidRootPart") and redSpawnPosition then
                local hrp = carrier.Character.HumanoidRootPart
                local distanceToRedSpawn = (hrp.Position - redSpawnPosition).Magnitude

                print("[ObjectiveService] Red carrier distance to spawn:", distanceToRedSpawn, "Position:", hrp.Position, "Red spawn:", redSpawnPosition)
                if distanceToRedSpawn < 15 then  -- Increased from 10 to 15
                    print("[ObjectiveService] Red team delivered! Distance:", distanceToRedSpawn)
                    Events.Objective:FireAllClients({
                        type = "ObjectiveDelivered",
                        by = carrier.UserId,
                        winner = "Attack"
                    })
                    stopFollowing()
                    carrier = nil
                    return "AttackWin"
                end
            end

            if not (carrier.Character and carrier.Character:FindFirstChild("HumanoidRootPart")) then
                -- Carrier died or lost character: respawn objective at random location
                carrier = nil
                stopFollowing()
                if objectiveModel then
                    local objSize = Config.OBJECTIVE.Size or Vector3.new(3,3,3)
                    local randomPos = getRandomObjectivePosition(greenSpawnPosition, Config.OBJECTIVE.SpawnDistance, objSize)
                    setObjectivePosition(objectiveModel, randomPos)
                    if objectivePart and objectivePart:IsA("BasePart") then
                        objectivePart.Transparency = 0
                    end
                    if objectivePrompt then objectivePrompt.ActionText = "Pick Up" end
                    setEffectsEnabled(objectiveModel, true)
                end
                Events.Objective:FireAllClients({ type="Dropped", by=0 })
            end
        end
    end

    return nil
end

-- Event handling with validation
table.insert(connections, Events.Objective.OnServerEvent:Connect(function(plr, payload)
    -- Validate player and payload
    local isPlayerValid, playerError = validatePlayerState(plr)
    if not isPlayerValid then
        warn(string.format("[ObjectiveService] Invalid player state: %s (UserId: %s)", playerError, plr.UserId or "unknown"))
        return
    end

    local isPayloadValid, payloadError = validateObjectiveEventPayload(payload)
    if not isPayloadValid then
        warn(string.format("[ObjectiveService] Invalid payload: %s (UserId: %s)", payloadError, plr.UserId))
        return
    end

    -- Process objective events
    if payload.type == "Pickup" and not carrier then
        carrier = plr
        Events.Objective:FireAllClients({ type="Carry", by=plr.UserId })
    elseif payload.type == "Drop" and carrier == plr then
        carrier = nil
        Events.Objective:FireAllClients({ type="Dropped", by=plr.UserId })
    end
end))

-- Start the actual round timer (called when live phase begins)
function ObjectiveService.StartTimer()
    roundStartTime = os.clock()
end

-- Function to clean up objective when round ends
function ObjectiveService.CleanupObjective()
    -- Stop following if active
    stopFollowing()

    -- Clear carrier
    carrier = nil

    -- Destroy objective model
    if objectiveModel then
        objectiveModel:Destroy()
        objectiveModel = nil
    end
    objectivePart = nil

    -- Clear prompt reference
    objectivePrompt = nil

    -- Clear spawn positions
    redSpawnPosition = nil
    greenSpawnPosition = nil
    roundStartTime = nil
end

-- Cleanup on game shutdown
game:BindToClose(function()
    cleanupConnections()
    ObjectiveService.CleanupObjective()
end)

return ObjectiveService
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="ModuleScript" referent="30">
      <Properties>
        <string name="Name">LobbyManager</string>
        <string name="Source">-- Manages lobby countdown when 2+ players are present

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local RoundService = require(script.Parent.Round.RoundService)

local LobbyManager = {}

local countdownConnection = nil
local isCountingDown = false
local countdownStartTime = nil

-- Get events for broadcasting
local function getEvents()
    local net = ReplicatedStorage:FindFirstChild("Net")
    if net and net:FindFirstChild("Events") then
        local ok, mod = pcall(require, net.Events)
        if ok and mod then return mod end
    end
    local folder = ReplicatedStorage:FindFirstChild("Remotes")
    if not folder then
        folder = Instance.new("Folder")
        folder.Name = "Remotes"
        folder.Parent = ReplicatedStorage
    end
    local function ensure(name, className)
        local obj = folder:FindFirstChild(name)
        if not obj then
            obj = Instance.new(className)
            obj.Name = name
            obj.Parent = folder
        end
        return obj
    end
    return {
        RoundChanged = ensure("RoundChanged", "RemoteEvent"),
    }
end

local Events = getEvents()

local function broadcast(message)
    Events.RoundChanged:FireAllClients({
        state = "Lobby",
        phase = "Lobby",
        message = message.text,
        timeRemaining = message.time,
        scores = { A = 0, B = 0 }  -- Include scores to avoid nil
    })
end

local function stopCountdown()
    if countdownConnection then
        countdownConnection:Disconnect()
        countdownConnection = nil
    end
    isCountingDown = false
    countdownStartTime = nil
    broadcast({ text = "Waiting for players..." })
end

local function startCountdown()
    -- Don't start if already counting or not in lobby
    if isCountingDown then return end
    if RoundService.IsInMatch() then return end

    -- Check player count
    if #Players:GetPlayers() &lt; 2 then
        stopCountdown()
        return
    end

    isCountingDown = true
    countdownStartTime = os.clock()
    local countdownDuration = 10
    local lastBroadcast = -1

    countdownConnection = RunService.Heartbeat:Connect(function()
        -- Check if we still have enough players
        if #Players:GetPlayers() &lt; 2 then
            stopCountdown()
            return
        end

        -- Check if round already started
        if RoundService.IsInMatch() then
            stopCountdown()
            return
        end

        local elapsed = os.clock() - countdownStartTime
        local remaining = math.ceil(countdownDuration - elapsed)

        if remaining ~= lastBroadcast and remaining >= 0 then
            broadcast({
                text = "Match starting in...",
                time = remaining
            })
            lastBroadcast = remaining
        end

        if elapsed >= countdownDuration then
            stopCountdown()
            -- Start the match
            if #Players:GetPlayers() >= 2 then
                task.spawn(function()
                    RoundService.StartLoop()
                end)
            end
        end
    end)
end

function LobbyManager.CheckAndStart()
    -- Only manage countdown if we're in lobby
    if RoundService.IsInMatch() then
        return
    end

    if #Players:GetPlayers() >= 2 then
        if not isCountingDown then
            startCountdown()
        end
    else
        stopCountdown()
    end
end

-- Monitor player changes
Players.PlayerAdded:Connect(function()
    task.wait(0.5) -- Let player load
    LobbyManager.CheckAndStart()
end)

Players.PlayerRemoving:Connect(function()
    task.defer(function() -- Check after player leaves
        LobbyManager.CheckAndStart()
    end)
end)

-- Also called when match ends
function LobbyManager.OnMatchEnd()
    task.wait(1) -- Brief pause after match
    LobbyManager.CheckAndStart()
end

-- Initial broadcast when server starts
task.spawn(function()
    task.wait(2)
    if #Players:GetPlayers() &lt; 2 then
        broadcast({ text = "Waiting for players..." })
    end
end)

return LobbyManager</string>
      </Properties>
    </Item>
    <Item class="Script" referent="31">
      <Properties>
        <string name="Name">Main</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- Bootstraps lobby countdown and round system

local Players = game:GetService("Players")

local LobbyManager = require(script.Parent.LobbyManager)
-- Ensure ConstructionService is initialized early (bootstrap)
pcall(function()
    local folder = script.Parent:FindFirstChild("Construction") or script.Parent:WaitForChild("Construction", 5)
    if folder then
        require(folder:WaitForChild("ConstructionService"))
    end
end)

-- Initialize lobby manager on server start
task.wait(1) -- Let services initialize
LobbyManager.CheckAndStart()
]]></string>
      </Properties>
    </Item>
    <Item class="Folder" referent="32">
      <Properties>
        <string name="Name">Round</string>
      </Properties>
      <Item class="ModuleScript" referent="33">
        <Properties>
          <string name="Name">RoundService</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Simple config - avoid dependency on ConfigLoader
local Config = {
    ROUND = {
        LENGTH_SEC = 180,
        WIN_TARGET = 3,
        SWITCH_SIDES_EVERY = 2,
        OBJECTIVE_TIME_LIMIT = 60  -- Time limit for objective capture
    },
}
local function getEvents()
    -- Prefer module if present, otherwise ensure Remotes directly
    local net = ReplicatedStorage:FindFirstChild("Net")
    if net and net:FindFirstChild("Events") then
        local ok, mod = pcall(require, net.Events)
        if ok and mod then return mod end
    end
    local function ensure(name, className)
        local folder = ReplicatedStorage:FindFirstChild("Remotes")
        if not folder then
            folder = Instance.new("Folder")
            folder.Name = "Remotes"
            folder.Parent = ReplicatedStorage
        end
        local obj = folder:FindFirstChild(name)
        if not obj then
            obj = Instance.new(className)
            obj.Name = name
            obj.Parent = folder
        end
        return obj
    end
    return {
        RoundChanged = ensure("RoundChanged", "RemoteEvent"),
        RequestSpawn = ensure("RequestSpawn", "RemoteFunction"),
        UseGadget = ensure("UseGadget", "RemoteEvent"),
        FireWeapon = ensure("FireWeapon", "RemoteEvent"),
        HitConfirm = ensure("HitConfirm", "RemoteEvent"),
        Objective = ensure("ObjectiveEvent", "RemoteEvent"),
    }
end

local Events = getEvents()
local State = require(script.Parent.RoundState)
local ObjectiveService = require(script.Parent.Parent.Gameplay.ObjectiveService)

local RoundService = {}
local scores = { A = 0, B = 0 }
local state: State.State = State.Lobby
local roundId = 0
local loopRunning = false

-- Public function to check if currently in a match
function RoundService.IsInMatch()
    return state ~= State.Lobby
end

local function broadcast(extra)
    local payload = { state = state, scores = scores, roundId = roundId }
    if extra then
        for k,v in pairs(extra) do payload[k] = v end
    end
    Events.RoundChanged:FireAllClients(payload)
end

function RoundService.StartLoop()
    if loopRunning then return end  -- Prevent multiple loops
    if state ~= State.Lobby then return end

    loopRunning = true
    roundId += 1
    scores = { A = 0, B = 0 }  -- Reset scores for new match

    while scores.A < Config.ROUND.WIN_TARGET and scores.B < Config.ROUND.WIN_TARGET do
        -- Start objective round - find red spawn position
        local redSpawn = workspace:FindFirstChild("RedSpawn")
        local redSpawnPos = redSpawn and redSpawn.Position or Vector3.new(-200, 1.5, -200)

        -- Prep countdown
        state = State.Prep
        local prepDur = 5
        local prepEnd = os.clock() + prepDur
        local lastRemain = -1

        -- Spawn objective at the start of prep phase
        ObjectiveService.StartRound(redSpawnPos)

        repeat
            local remain = math.max(0, math.ceil(prepEnd - os.clock()))
            if remain ~= lastRemain then
                broadcast({ timeRemaining = remain, phase = "Prep" })
                lastRemain = remain
            end
            task.wait(0.2)
        until os.clock() >= prepEnd

        -- Live (round) countdown handled inside PlayRound via callback
        state = State.Live
        broadcast({ phase = "Live" })

        -- Start the objective timer NOW (when live phase begins)
        ObjectiveService.StartTimer()

        -- Run the round with proper win conditions
        local liveLast = -1
        local roundResult = RoundService.PlayRound(function(remain)
            if remain ~= liveLast then
                broadcast({ timeRemaining = remain, phase = "Live" })
                liveLast = remain
            end
        end)

        if roundResult == "AttackWin" then
            scores.A += 1
            print("[RoundService] Attack wins! Red team delivered. Score:", scores.A, "-", scores.B)
        elseif roundResult == "DefenseWin" then
            scores.B += 1
            print("[RoundService] Defense wins! Time expired. Score:", scores.A, "-", scores.B)
        else
            print("[RoundService] Round ended with no result:", roundResult)
        end

        -- Clean up objective when round ends
        ObjectiveService.CleanupObjective()

        -- End screen countdown
        state = State.End
        local endDur = 4
        local endAt = os.clock() + endDur
        lastRemain = -1
        repeat
            local remain = math.max(0, math.ceil(endAt - os.clock()))
            if remain ~= lastRemain then
                broadcast({ timeRemaining = remain, phase = "End" })
                lastRemain = remain
            end
            task.wait(0.2)
        until os.clock() >= endAt
    end
    state = State.Lobby
    loopRunning = false  -- Reset flag when match ends
    broadcast({ phase = "MatchComplete" })

    -- Notify lobby manager to handle countdown
    local LobbyManager = require(script.Parent.Parent.LobbyManager)
    LobbyManager.OnMatchEnd()
end

function RoundService.PlayRound(onUpdate)
    local startTime = os.clock()
    local timeLimit = Config.ROUND.OBJECTIVE_TIME_LIMIT or 60

    while true do
        local elapsed = os.clock() - startTime

        -- Check if time limit reached
        if elapsed >= timeLimit then return "DefenseWin" end

        -- Update clients with remaining time occasionally
        if onUpdate then
            local remain = math.max(0, math.ceil(timeLimit - elapsed))
            onUpdate(remain)
        end

        -- Check objective service for win conditions
        local objectiveResult = ObjectiveService.Tick()
        if objectiveResult then
            print("[RoundService] ObjectiveService returned:", objectiveResult)
            return objectiveResult
        end

        -- Small delay to prevent excessive CPU usage
        task.wait(0.25)
    end
end

return RoundService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="34">
        <Properties>
          <string name="Name">RoundState</string>
          <string name="Source"><![CDATA[-- Round state enum
export type State = "Lobby" | "Prep" | "Live" | "End"
local State = { Lobby = "Lobby", Prep = "Prep", Live = "Live", End = "End" }
return State

]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Script" referent="35">
      <Properties>
        <string name="Name">Setup</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- Game bootstrap: teams, baseplate, spawns, and team assignment
local Players = game:GetService("Players")
local TeamsService = game:GetService("Teams")
local StarterPlayer = game:GetService("StarterPlayer")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Simple config - no complex loading to avoid issues
local Config = {
    forceR6 = true,
    baseplate = {
        size = Vector3.new(100, 1, 100),  -- Smaller for testing
        color = Color3.fromRGB(163, 162, 165),
        name = "Baseplate"
    },
    spawns = {
        inset = 10,
        size = Vector3.new(8, 1, 8),
        forceFieldDuration = 0
    },
    teams = {
        red = { name = "Red", brickColor = "Really red" },
        green = { name = "Green", brickColor = "Lime green" },
        autoAssignable = false,
        assignment = "alternate",
    },
}


-- Global baseplate size for use in other functions
local BASEPLATE_SIZE = Config.baseplate.size

if Config.forceR6 then
    -- Try the correct way to set R6 in newer Roblox versions
    pcall(function()
        -- Try different methods for R6 enforcement
        if StarterPlayer:FindFirstChild("CharacterRigType") then
            StarterPlayer.CharacterRigType = Enum.HumanoidRigType.R6
        else
            -- Alternative method for older versions
            local humanoidDescription = Instance.new("HumanoidDescription")
            humanoidDescription.RigType = Enum.HumanoidRigType.R6
            StarterPlayer.HumanoidDescription = humanoidDescription
        end
    end)
end

-- Disable chat at the server level to prevent client-side ChatScript errors
pcall(function()
    local StarterGui = game:GetService("StarterGui")
    -- Set server-wide chat settings
    StarterGui.ShowDevelopmentGui = false

    -- Try to disable chat service if available
    local TextChatService = game:GetService("TextChatService")
    if TextChatService then
        TextChatService.ChatVersion = Enum.ChatVersion.LegacyChatService
    end
end)

-- Simple team creation
local function createTeam(name, brickColor)
    local team = Instance.new("Team")
    team.Name = name
    team.TeamColor = BrickColor.new(brickColor)
    team.AutoAssignable = false
    team.Parent = TeamsService
    return team
end

local redTeam = createTeam("Red", "Really red")
local greenTeam = createTeam("Green", "Lime green")

-- Simple baseplate creation
local function createBaseplate()
    -- Remove existing baseplate if it exists
    local existing = Workspace:FindFirstChild("Baseplate")
    if existing then
        existing:Destroy()
    end

    -- Use the global baseplate size

    local bp = Instance.new("Part")
    bp.Name = "Baseplate"
    bp.Anchored = true
    bp.Size = BASEPLATE_SIZE
    bp.Position = Vector3.new(0, 0.5, 0)
    bp.TopSurface = Enum.SurfaceType.Smooth
    bp.BottomSurface = Enum.SurfaceType.Smooth
    bp.Color = Color3.fromRGB(163, 162, 165)
    -- Keep as an invisible logical reference for bounds/height; terrain will be the visible ground
    bp.Transparency = 1
    bp.CanCollide = false
    bp.Parent = Workspace

    return bp
end

local baseplate = createBaseplate()

-- Create grass terrain covering the base area
pcall(function()
    local terrain = Workspace.Terrain
    -- Clear existing terrain for a clean starting state
    terrain:Clear()
    local thickness = 8
    local topY = baseplate.Position.Y + (BASEPLATE_SIZE.Y * 0.5)
    local offsetDown = 2 -- push grass safely below spawns/baseplate
    local cf = CFrame.new(0, (topY - offsetDown) - thickness * 0.5, 0)
    local pad = 1.2 -- extend a bit beyond the baseplate borders
    local fillSize = Vector3.new(BASEPLATE_SIZE.X * pad, thickness, BASEPLATE_SIZE.Z * pad)
    terrain:FillBlock(cf, fillSize, Enum.Material.Grass)
end)

-- Simple spawn creation
local function createSpawn(name, team, position)
    -- Remove existing spawn if it exists
    local existing = Workspace:FindFirstChild(name)
    if existing then
        existing:Destroy()
    end

    local spawn = Instance.new("SpawnLocation")
    spawn.Name = name
    spawn.Anchored = true
    spawn.CanCollide = true
    spawn.Neutral = false
    spawn.Duration = 0 -- No forcefield
    spawn.AllowTeamChangeOnTouch = false
    spawn.Size = Vector3.new(8, 1, 8)
    spawn.TeamColor = team.TeamColor
    spawn.BrickColor = team.TeamColor
    spawn.Color = team.TeamColor.Color
    spawn.CFrame = CFrame.new(position)
    spawn.Parent = Workspace

    return spawn
end

-- Simple spawn positioning - adjusted for smaller baseplate
local halfSize = BASEPLATE_SIZE.X * 0.4  -- 40% from center
local spawnY = baseplate.Position.Y + (BASEPLATE_SIZE.Y * 0.5) + 0.5

local redPos = Vector3.new(-halfSize, spawnY, -halfSize)   -- Left side
local greenPos = Vector3.new(halfSize, spawnY, halfSize)   -- Right side

local redSpawn = createSpawn("RedSpawn", redTeam, redPos)
local greenSpawn = createSpawn("GreenSpawn", greenTeam, greenPos)

-- Carve air above spawns to guarantee visibility (in case terrain overlaps)
pcall(function()
    local terrain = Workspace.Terrain
    local function clearAround(part)
        if not (part and part:IsA("BasePart")) then return end
        local size = part.Size
        local pad = 6
        local height = 64
        local cf = CFrame.new(part.Position.X, part.Position.Y + height * 0.5, part.Position.Z)
        terrain:FillBlock(cf, Vector3.new(size.X + pad, height, size.Z + pad), Enum.Material.Air)
    end
    clearAround(redSpawn)
    clearAround(greenSpawn)
end)

-- Disable any other spawn locations that might exist in the place/template
for _, inst in ipairs(Workspace:GetDescendants()) do
    if inst:IsA("SpawnLocation") and inst.Name ~= "RedSpawn" and inst.Name ~= "GreenSpawn" then
        pcall(function() inst.Enabled = false end)
        inst.Neutral = false
    end
end

-- Simple team assignment: alternate between teams
local function teamCounts()
    local r, g = 0, 0
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Team == redTeam then r += 1 elseif p.Team == greenTeam then g += 1 end
    end
    return r, g
end

local nextTeamIsRed = true
local function assignPlayerToTeam(player: Player)
    local rCount, gCount = teamCounts()
    local team
    if rCount == gCount then
        team = nextTeamIsRed and redTeam or greenTeam
        nextTeamIsRed = not nextTeamIsRed
    else
        team = (rCount < gCount) and redTeam or greenTeam
    end
    player.Team = team
    player.Neutral = false
    pcall(function() player:LoadCharacter() end)
end

for _, plr in ipairs(Players:GetPlayers()) do assignPlayerToTeam(plr) end
Players.PlayerAdded:Connect(function(plr)
    task.wait(0.2)
    assignPlayerToTeam(plr)
end)
]]></string>
      </Properties>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="36">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterCharacterScripts" referent="37">
      <Properties>
        <string name="Name">StarterCharacterScripts</string>
      </Properties>
    </Item>
    <Item class="StarterPlayerScripts" referent="38">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="39">
        <Properties>
          <string name="Name">DisableChat</string>
          <string name="Source"><![CDATA[-- Immediate chat disabling to prevent ChatScript errors
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")

-- Disable chat immediately, before other scripts can interfere
pcall(function()
    StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
end)

-- Additional cleanup after a brief delay
task.spawn(function()
    task.wait(1)

    -- Ensure chat stays disabled
    pcall(function()
        StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
    end)

    -- Try to clear any remaining chat elements
    pcall(function()
        local success = pcall(function()
            StarterGui:SetCore("ChatActive", false)
        end)
        if not success then
            -- If ChatActive doesn't work, try alternative
            StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
        end
    end)
end)

-- Aggressively remove legacy ChatScript to avoid SetCore errors
task.spawn(function()
    local localPlayer = Players.LocalPlayer
    if not localPlayer then return end
    local ps = localPlayer:FindFirstChild("PlayerScripts") or localPlayer:WaitForChild("PlayerScripts", 5)
    if not ps then return end

    local function scrub(child)
        if child and child.Name == "ChatScript" then
            pcall(function()
                child:Destroy()
            end)
        end
    end

    -- Remove any existing ChatScript
    for _, ch in ipairs(ps:GetChildren()) do
        scrub(ch)
    end
    -- Remove if it appears later
    ps.ChildAdded:Connect(scrub)
end)
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="40">
        <Properties>
          <string name="Name">DisableClassicChat</string>
          <string name="Source"><![CDATA[-- This script is now disabled to avoid conflicts with Roblox's core chat systems
-- All chat disabling is handled by DisableChat.client.lua using proper APIs

-- Keeping this file for compatibility but doing nothing to avoid errors
print("[DisableClassicChat] Chat disabling handled by main DisableChat script")
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="41">
        <Properties>
          <string name="Name">Effects</string>
        </Properties>
        <Item class="LocalScript" referent="42">
          <Properties>
            <string name="Name">BoardFx</string>
            <string name="Source"><![CDATA[-- Simple local FX for board kicks: camera shake

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local Events
do
    local ok, mod = pcall(function() return require(ReplicatedStorage.Net.Events) end)
    if ok then Events = mod end
end

local function shakeCamera(mag, dur)
    local cam = workspace.CurrentCamera
    if not cam then return end
    local t = 0
    local conn
    conn = RunService.RenderStepped:Connect(function(dt)
        t += dt
        if t >= dur then
            if conn then conn:Disconnect() end
            return
        end
        local off = Vector3.new((math.random()-0.5)*mag, (math.random()-0.5)*mag, 0)
        cam.CFrame = cam.CFrame * CFrame.new(off)
    end)
end

local function onFX(payload)
    if type(payload) ~= "table" then return end
    if payload.kind == "Kick" then
        shakeCamera(payload.mag or 0.3, payload.dur or 0.1)
    end
end

if Events and Events.BoardFX then
    Events.BoardFX.OnClientEvent:Connect(onFX)
end

]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="43">
        <Properties>
          <string name="Name">Input</string>
        </Properties>
        <Item class="LocalScript" referent="44">
          <Properties>
            <string name="Name">BoardUp</string>
            <string name="Source"><![CDATA[-- Client helper: while holding the Board Up prompt key, repeatedly ask server to place boards.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ProximityPromptService = game:GetService("ProximityPromptService")
local UIS = game:GetService("UserInputService")

local Events do
    local ok, mod = pcall(function() return require(ReplicatedStorage:WaitForChild("Net"):WaitForChild("Events")) end)
    if ok then Events = mod end
end

local interval = 0.2
local boardKey = Enum.KeyCode.E
local kickKey = Enum.KeyCode.Q
do
    local ok, ConfigLoader = pcall(function() return require(ReplicatedStorage.Shared.ConfigLoader) end)
    if ok then
        local cfg = ConfigLoader.Load("BoardUpClient")
        if cfg and cfg.CONSTRUCTION and cfg.CONSTRUCTION.BOARDUP then
            if cfg.CONSTRUCTION.BOARDUP.Hold then
                interval = math.max(0.05, cfg.CONSTRUCTION.BOARDUP.Hold)
            end
            if cfg.CONSTRUCTION.BOARDUP.KeyCode then
                boardKey = cfg.CONSTRUCTION.BOARDUP.KeyCode
            end
            if cfg.CONSTRUCTION.DESTROY and cfg.CONSTRUCTION.DESTROY.KeyCode then
                kickKey = cfg.CONSTRUCTION.DESTROY.KeyCode
            end
        end
    end
end

local activePrompt: ProximityPrompt? = nil
local holdAccum = 0
local boardHeld = false
local keyHeld = false

local function isOpeningPrompt(prompt: ProximityPrompt)
    local p = prompt and prompt.Parent
    return p and p:IsA("BasePart") and p.Parent and p.Parent.Name == "Openings"
end

-- Track currently shown opening prompt (do not clear on Hidden to avoid single-board stalls)
ProximityPromptService.PromptShown:Connect(function(prompt)
    if isOpeningPrompt(prompt) then
        activePrompt = prompt
        holdAccum = 0
    end
end)

-- Also track actual hold begin/end for reliable state
ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
    if isOpeningPrompt(prompt) then
        activePrompt = prompt
        holdAccum = 0
        boardHeld = true
        keyHeld = true
    end
end)

ProximityPromptService.PromptButtonHoldEnded:Connect(function(prompt)
    if prompt == activePrompt then
        boardHeld = false
        holdAccum = 0
    end
end)

-- Do not forcibly clear on PromptHidden; engine may hide between triggers.

-- Track board key state
-- We query key state directly per-frame; no need to observe InputBegan/Ended

-- Drive continuous placement independent of the engine's prompt hold cycle
local RunService = game:GetService("RunService")
-- Track physical key state regardless of gameProcessedEvent
UIS.InputBegan:Connect(function(input)
    if input.KeyCode == boardKey then keyHeld = true end
end)
UIS.InputEnded:Connect(function(input)
    if input.KeyCode == boardKey then keyHeld = false end
end)

RunService.Heartbeat:Connect(function(dt)
    if not (activePrompt and activePrompt.Parent and activePrompt.Enabled) then
        holdAccum = 0
        return
    end
    -- Build action while E is held (only when the visible prompt is NOT Kick)
    if keyHeld and Events and Events.BoardUp and (activePrompt.Name ~= "KickPrompt") then
        holdAccum += dt
        if holdAccum >= interval then
            holdAccum -= interval
            Events.BoardUp:FireServer(activePrompt.Parent)
        end
    end
end)

-- Kick action on key press (single; strong when Shift + Key)
UIS.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == kickKey and activePrompt and activePrompt.Enabled and Events and Events.BoardKick then
        local strong = UIS:IsKeyDown(Enum.KeyCode.LeftShift) or UIS:IsKeyDown(Enum.KeyCode.RightShift)
        Events.BoardKick:FireServer(activePrompt.Parent, strong)
    end
end)
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="45">
          <Properties>
            <string name="Name">Construction</string>
            <string name="Source"><![CDATA[-- Client input: press B to request construction

local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Events
do
    local ok, mod = pcall(function() return require(ReplicatedStorage:WaitForChild("Net"):WaitForChild("Events")) end)
    if ok and mod then Events = mod else
        local folder = ReplicatedStorage:WaitForChild("Remotes", 5)
        local function get(name)
            return folder and (folder:FindFirstChild(name) or folder:WaitForChild(name, 5)) or nil
        end
        Events = { Construction = get("ConstructionRequest") }
    end
end

local debounce = false
local COOLDOWN = 0.5

UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.B then
        if debounce then return end
        debounce = true
        if Events and Events.Construction then
            print("[Construction] Sending build request (B pressed)")
            Events.Construction:FireServer()
        else
            warn("[Construction] Remote missing; server may not be ready")
        end
        task.delay(COOLDOWN, function() debounce = false end)
    end
end)
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="46">
          <Properties>
            <string name="Name">InputController</string>
            <string name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function getEvents()
    local ok, mod = pcall(function() return require(ReplicatedStorage.Net.Events) end)
    if ok and mod then return mod end
    local folder = ReplicatedStorage:WaitForChild("Remotes", 5)
    local function get(name)
        return folder and (folder:FindFirstChild(name) or folder:WaitForChild(name, 5)) or nil
    end
    return {
        FireWeapon = get("FireWeapon"),
    }
end

-- Input validation functions
local function validateVector3(vec)
    if typeof(vec) ~= "Vector3" then return false end
    if vec.X ~= vec.X or vec.Y ~= vec.Y or vec.Z ~= vec.Z then return false end -- Check for NaN
    return true
end

local function validateWeaponInput()
    local cam = workspace.CurrentCamera
    if not cam then return false, "No camera" end

    local origin = cam.CFrame.Position
    local dir = cam.CFrame.LookVector * 500

    if not validateVector3(origin) or not validateVector3(dir) then
        return false, "Invalid camera vectors"
    end

    return true, origin, dir
end

local Events = getEvents()

local firing = false

UserInputService.InputBegan:Connect(function(io, gpe)
    if gpe then return end
    if io.UserInputType == Enum.UserInputType.MouseButton1 then
        firing = true
    end
end)

UserInputService.InputEnded:Connect(function(io)
    if io.UserInputType == Enum.UserInputType.MouseButton1 then
        firing = false
    end
end)

-- TODO: ISSUE #10 - Performance Issue: RenderStepped runs every frame for input
-- Should use heartbeat or input service events instead of polling every frame
game:GetService("RunService").RenderStepped:Connect(function()
    if not firing then return end

    local isValid, origin, dir = validateWeaponInput()
    if not isValid then
        warn("[InputController] Invalid weapon input: " .. origin)
        return
    end

    -- Add error handling for server communication
    local success, result = pcall(function()
        return Events.FireWeapon:FireServer({ origin = origin, dir = dir, weaponName = "Carbine" })
    end)

    if not success then
        warn("[InputController] Failed to fire weapon: " .. result)
    end
end)
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="47">
          <Properties>
            <string name="Name">KickPromptControl</string>
            <string name="Source"><![CDATA[-- Client-side filter: show Kick prompt only on the closest opening that has any boards.
-- If the closest opening with boards is not fully sealed, we still hide Kick prompts elsewhere.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local function getHRP()
    local c = player.Character or player.CharacterAdded:Wait()
    return c:WaitForChild("HumanoidRootPart")
end

local PlankWidth = 1.5
local MaxBoardsPerOpening = 24
local DestroyDistance = 12
do
    local ok, ConfigLoader = pcall(function() return require(ReplicatedStorage.Shared.ConfigLoader) end)
    if ok then
        local cfg = ConfigLoader.Load("KickPromptControl")
        if cfg and cfg.CONSTRUCTION then
            local bu = cfg.CONSTRUCTION.BOARDUP
            if bu then
                PlankWidth = bu.PlankWidth or PlankWidth
                MaxBoardsPerOpening = bu.MaxBoardsPerOpening or MaxBoardsPerOpening
            end
            local d = cfg.CONSTRUCTION.DESTROY
            if d then
                DestroyDistance = d.Distance or DestroyDistance
            end
        end
    end
end

local function computeQuota(proxy: BasePart)
    local axis = proxy:GetAttribute("Axis") or "x"
    local length = (axis == "x") and proxy.Size.X or proxy.Size.Z
    local N = math.max(1, math.ceil(length / PlankWidth))
    N = math.min(N, MaxBoardsPerOpening)
    local boards = proxy:FindFirstChild("Boards")
    local current = boards and #boards:GetChildren() or 0
    return N, current
end

local function eachOpenings()
    local res = {}
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") then
            local openings = model:FindFirstChild("Openings")
            if openings then
                for _, proxy in ipairs(openings:GetChildren()) do
                    if proxy:IsA("BasePart") then
                        table.insert(res, proxy)
                    end
                end
            end
        end
    end
    return res
end

local function step()
    local hrp = getHRP()
    local nearest, nd2
    for _, proxy in ipairs(eachOpenings()) do
        local boardsFolder = proxy:FindFirstChild("Boards")
        if boardsFolder and #boardsFolder:GetChildren() > 0 then
            local d2 = (proxy.Position - hrp.Position).Magnitude
            if d2 <= DestroyDistance and (not nd2 or d2 < nd2) then
                nearest, nd2 = proxy, d2
            end
        end
    end

    -- Hide all kick prompts except the nearest with boards; if nearest is not sealed, hide all
    for _, proxy in ipairs(eachOpenings()) do
        local kp = proxy:FindFirstChild("KickPrompt")
        if kp and kp:IsA("ProximityPrompt") then
            kp.Enabled = false
        end
    end

    if nearest then
        local N, current = computeQuota(nearest)
        if current >= N then
            local kp = nearest:FindFirstChild("KickPrompt")
            if kp and kp:IsA("ProximityPrompt") then
                kp.Enabled = true
            end
        end
    end
end

task.spawn(function()
    while true do
        step()
        task.wait(0.25)
    end
end)

]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="48">
        <Properties>
          <string name="Name">UI</string>
        </Properties>
        <Item class="LocalScript" referent="49">
          <Properties>
            <string name="Name">Hud</string>
            <string name="Source">-- Enhanced HUD with clear score display, timer, and team assignment

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Camera = workspace.CurrentCamera

local function getEvents()
    local ok, mod = pcall(function() return require(ReplicatedStorage.Net.Events) end)
    if ok and mod then return mod end
    local folder = ReplicatedStorage:FindFirstChild("Remotes") or ReplicatedStorage:WaitForChild("Remotes", 5)
    local function get(name)
        return folder and (folder:FindFirstChild(name) or folder:WaitForChild(name, 5)) or nil
    end
    return {
        RoundChanged = get("RoundChanged"),
        Objective = get("ObjectiveEvent"),
    }
end

local Events = getEvents()

local player = Players.LocalPlayer
local gui = Instance.new("ScreenGui")
gui.Name = "HUD"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.DisplayOrder = 5
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Wait for PlayerGui to be ready and avoid conflicts
local playerGui = player:WaitForChild("PlayerGui")

-- Clean up any existing HUD
local existingHUD = playerGui:FindFirstChild("HUD")
if existingHUD then
    existingHUD:Destroy()
end

-- Add GUI to PlayerGui after a brief delay to avoid styling conflicts
task.wait(0.5)
gui.Parent = playerGui

-- Main container (wider, more prominent)
local container = Instance.new("Frame")
container.Size = UDim2.new(0, 460, 0, 100)
container.AnchorPoint = Vector2.new(0.5, 0)
container.Position = UDim2.new(0.5, 0, 0, 20)
container.BackgroundColor3 = Color3.fromRGB(15, 15, 18)
container.BackgroundTransparency = 0.05
container.BorderSizePixel = 0
container.Parent = gui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 16)
corner.Parent = container

local stroke = Instance.new("UIStroke")
stroke.Thickness = 2
stroke.Color = Color3.fromRGB(255, 255, 255)
stroke.Transparency = 0.9
stroke.Parent = container

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(28,28,35)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(22,22,28)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(18,18,24))
}
gradient.Rotation = 90
gradient.Parent = container

-- Score display section
local scoreSection = Instance.new("Frame")
scoreSection.Size = UDim2.new(1, -40, 0, 40)
scoreSection.Position = UDim2.new(0, 20, 0, 12)
scoreSection.BackgroundTransparency = 1
scoreSection.Parent = container

-- Attack team score
local attackFrame = Instance.new("Frame")
attackFrame.Size = UDim2.new(0, 160, 1, 0)
attackFrame.Position = UDim2.new(0, 0, 0, 0)
attackFrame.BackgroundColor3 = Color3.fromRGB(40, 100, 180)
attackFrame.BackgroundTransparency = 0.7
attackFrame.BorderSizePixel = 0
attackFrame.Parent = scoreSection

local attackCorner = Instance.new("UICorner")
attackCorner.CornerRadius = UDim.new(0, 10)
attackCorner.Parent = attackFrame

local attackStroke = Instance.new("UIStroke")
attackStroke.Thickness = 3
attackStroke.Color = Color3.fromRGB(255, 100, 100)
attackStroke.Transparency = 1  -- Initially transparent
attackStroke.Parent = attackFrame

local attackGradient = Instance.new("UIGradient")
attackGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.new(1,1,1)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(200,200,200))
}
attackGradient.Rotation = 90
attackGradient.Parent = attackFrame

local attackTeamLabel = Instance.new("TextLabel")
attackTeamLabel.Size = UDim2.new(0.55, 0, 0.5, 0)
attackTeamLabel.Position = UDim2.new(0, 12, 0, 0)
attackTeamLabel.BackgroundTransparency = 1
attackTeamLabel.TextColor3 = Color3.fromRGB(180, 200, 220)
attackTeamLabel.TextXAlignment = Enum.TextXAlignment.Left
attackTeamLabel.Font = Enum.Font.SourceSansSemibold
attackTeamLabel.TextSize = 12
attackTeamLabel.Text = "ATTACK"
attackTeamLabel.Parent = attackFrame

local attackScoreLabel = Instance.new("TextLabel")
attackScoreLabel.Size = UDim2.new(0.45, -12, 1, 0)
attackScoreLabel.Position = UDim2.new(0.55, 0, 0, 0)
attackScoreLabel.BackgroundTransparency = 1
attackScoreLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
attackScoreLabel.TextXAlignment = Enum.TextXAlignment.Right
attackScoreLabel.Font = Enum.Font.SourceSansBold
attackScoreLabel.TextSize = 28
attackScoreLabel.Text = "0"
attackScoreLabel.Parent = attackFrame

local attackIcon = Instance.new("TextLabel")
attackIcon.Size = UDim2.new(0.55, 0, 0.5, 0)
attackIcon.Position = UDim2.new(0, 12, 0.5, 0)
attackIcon.BackgroundTransparency = 1
attackIcon.TextColor3 = Color3.fromRGB(160, 180, 200)
attackIcon.TextXAlignment = Enum.TextXAlignment.Left
attackIcon.Font = Enum.Font.SourceSansSemibold
attackIcon.TextSize = 11
attackIcon.Text = "⚔️ OFFENSIVE"
attackIcon.Parent = attackFrame

-- Defense team score
local defenseFrame = Instance.new("Frame")
defenseFrame.Size = UDim2.new(0, 160, 1, 0)
defenseFrame.AnchorPoint = Vector2.new(1, 0)
defenseFrame.Position = UDim2.new(1, 0, 0, 0)
defenseFrame.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
defenseFrame.BackgroundTransparency = 0.7
defenseFrame.BorderSizePixel = 0
defenseFrame.Parent = scoreSection

local defenseCorner = Instance.new("UICorner")
defenseCorner.CornerRadius = UDim.new(0, 10)
defenseCorner.Parent = defenseFrame

local defenseStroke = Instance.new("UIStroke")
defenseStroke.Thickness = 3
defenseStroke.Color = Color3.fromRGB(100, 255, 100)
defenseStroke.Transparency = 1  -- Initially transparent
defenseStroke.Parent = defenseFrame

local defenseGradient = Instance.new("UIGradient")
defenseGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.new(1,1,1)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(200,200,200))
}
defenseGradient.Rotation = 90
defenseGradient.Parent = defenseFrame

local defenseScoreLabel = Instance.new("TextLabel")
defenseScoreLabel.Size = UDim2.new(0.45, -12, 1, 0)
defenseScoreLabel.Position = UDim2.new(0, 12, 0, 0)
defenseScoreLabel.BackgroundTransparency = 1
defenseScoreLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
defenseScoreLabel.TextXAlignment = Enum.TextXAlignment.Left
defenseScoreLabel.Font = Enum.Font.SourceSansBold
defenseScoreLabel.TextSize = 28
defenseScoreLabel.Text = "0"
defenseScoreLabel.Parent = defenseFrame

local defenseTeamLabel = Instance.new("TextLabel")
defenseTeamLabel.Size = UDim2.new(0.55, 0, 0.5, 0)
defenseTeamLabel.AnchorPoint = Vector2.new(1, 0)
defenseTeamLabel.Position = UDim2.new(1, -12, 0, 0)
defenseTeamLabel.BackgroundTransparency = 1
defenseTeamLabel.TextColor3 = Color3.fromRGB(220, 180, 180)
defenseTeamLabel.TextXAlignment = Enum.TextXAlignment.Right
defenseTeamLabel.Font = Enum.Font.SourceSansSemibold
defenseTeamLabel.TextSize = 12
defenseTeamLabel.Text = "DEFENSE"
defenseTeamLabel.Parent = defenseFrame

local defenseIcon = Instance.new("TextLabel")
defenseIcon.Size = UDim2.new(0.55, 0, 0.5, 0)
defenseIcon.AnchorPoint = Vector2.new(1, 0)
defenseIcon.Position = UDim2.new(1, -12, 0.5, 0)
defenseIcon.BackgroundTransparency = 1
defenseIcon.TextColor3 = Color3.fromRGB(200, 160, 160)
defenseIcon.TextXAlignment = Enum.TextXAlignment.Right
defenseIcon.Font = Enum.Font.SourceSansSemibold
defenseIcon.TextSize = 11
defenseIcon.Text = "DEFENSIVE 🛡️"
defenseIcon.Parent = defenseFrame

-- VS divider
local vsFrame = Instance.new("Frame")
vsFrame.Size = UDim2.new(0, 60, 0, 30)
vsFrame.AnchorPoint = Vector2.new(0.5, 0.5)
vsFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
vsFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
vsFrame.BorderSizePixel = 0
vsFrame.Parent = scoreSection

local vsCorner = Instance.new("UICorner")
vsCorner.CornerRadius = UDim.new(0.5, 0)
vsCorner.Parent = vsFrame

local vsStroke = Instance.new("UIStroke")
vsStroke.Thickness = 2
vsStroke.Color = Color3.fromRGB(255, 255, 255)
vsStroke.Transparency = 0.8
vsStroke.Parent = vsFrame

local vsLabel = Instance.new("TextLabel")
vsLabel.Size = UDim2.new(1, 0, 1, 0)
vsLabel.BackgroundTransparency = 1
vsLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
vsLabel.Font = Enum.Font.SourceSansBold
vsLabel.TextSize = 16
vsLabel.Text = "VS"
vsLabel.Parent = vsFrame

-- Bottom info section
local infoSection = Instance.new("Frame")
infoSection.Size = UDim2.new(1, -40, 0, 36)
infoSection.Position = UDim2.new(0, 20, 1, -44)
infoSection.BackgroundTransparency = 1
infoSection.Parent = container


-- Timer display
local timerCard = Instance.new("Frame")
timerCard.Size = UDim2.new(0, 140, 1, 0)
timerCard.AnchorPoint = Vector2.new(1, 0)
timerCard.Position = UDim2.new(1, 0, 0, 0)
timerCard.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
timerCard.BackgroundTransparency = 0.3
timerCard.BorderSizePixel = 0
timerCard.Parent = infoSection

local timerCardCorner = Instance.new("UICorner")
timerCardCorner.CornerRadius = UDim.new(0, 10)
timerCardCorner.Parent = timerCard

local timerIcon = Instance.new("TextLabel")
timerIcon.Size = UDim2.new(0, 30, 1, 0)
timerIcon.Position = UDim2.new(0, 8, 0, 0)
timerIcon.BackgroundTransparency = 1
timerIcon.TextColor3 = Color3.fromRGB(180, 180, 180)
timerIcon.Font = Enum.Font.SourceSansSemibold
timerIcon.TextSize = 16
timerIcon.Text = "⏱"
timerIcon.Parent = timerCard

local timerText = Instance.new("TextLabel")
timerText.Size = UDim2.new(1, -38, 1, 0)
timerText.Position = UDim2.new(0, 38, 0, 0)
timerText.BackgroundTransparency = 1
timerText.TextColor3 = Color3.fromRGB(255, 255, 255)
timerText.TextXAlignment = Enum.TextXAlignment.Center
timerText.Font = Enum.Font.SourceSansBold
timerText.TextSize = 18
timerText.Text = "0:00"
timerText.Parent = timerCard

-- Phase indicator
local phaseLabel = Instance.new("TextLabel")
phaseLabel.Size = UDim2.new(0, 160, 1, 0)
phaseLabel.AnchorPoint = Vector2.new(0.5, 0)
phaseLabel.Position = UDim2.new(0.5, 0, 0, 0)
phaseLabel.BackgroundTransparency = 1
phaseLabel.TextColor3 = Color3.fromRGB(160, 160, 160)
phaseLabel.Font = Enum.Font.SourceSansSemibold
phaseLabel.TextSize = 13
phaseLabel.Text = "WAITING"
phaseLabel.Parent = infoSection

-- Enhanced toast notification
local toastFrame = Instance.new("Frame")
toastFrame.Size = UDim2.new(0, 400, 0, 42)
toastFrame.AnchorPoint = Vector2.new(0.5, 0)
toastFrame.Position = UDim2.new(0.5, 0, 0, 130)
toastFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
toastFrame.BackgroundTransparency = 0
toastFrame.BorderSizePixel = 0
toastFrame.Visible = false
toastFrame.Parent = gui

local toastCorner = Instance.new("UICorner")
toastCorner.CornerRadius = UDim.new(0, 12)
toastCorner.Parent = toastFrame

local toastStroke = Instance.new("UIStroke")
toastStroke.Thickness = 2
toastStroke.Color = Color3.fromRGB(255, 200, 100)
toastStroke.Transparency = 0.3
toastStroke.Parent = toastFrame

local toastGradient = Instance.new("UIGradient")
toastGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.new(1,1,1)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(180,180,180))
}
toastGradient.Rotation = 90
toastGradient.Parent = toastFrame

local toastText = Instance.new("TextLabel")
toastText.Size = UDim2.new(1, -20, 1, 0)
toastText.Position = UDim2.new(0, 10, 0, 0)
toastText.BackgroundTransparency = 1
toastText.TextColor3 = Color3.fromRGB(255, 255, 255)
toastText.Font = Enum.Font.SourceSansBold
toastText.TextSize = 16
toastText.Text = ""
toastText.Parent = toastFrame

-- Arrow removed - no directional guidance

-- State variables
local currentState = "Lobby"
local scores = {A = 0, B = 0}
local roundTimeRemaining = nil
local roundPhase = nil
local objectiveTimeLimit = 60
local objectiveStartTime = 0
local isCarrier = false
local greenSpawnPos = nil
local redSpawnPos = nil

local function formatTime(s)
    if not s or s &lt; 0 then return "--:--" end
    local m = math.floor(s/60)
    local sec = math.floor(s % 60)
    return string.format("%d:%02d", m, sec)
end

local function animateToast(text, duration, color)
    toastText.Text = text or ""
    toastFrame.Visible = text ~= nil and text ~= ""

    if toastFrame.Visible then
        -- Set color
        local toastColor = color or Color3.fromRGB(255, 200, 100)
        toastStroke.Color = toastColor

        -- Animate in
        toastFrame.Position = UDim2.new(0.5, 0, 0, 110)
        local tweenIn = TweenService:Create(
            toastFrame,
            TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
            {Position = UDim2.new(0.5, 0, 0, 130)}
        )
        tweenIn:Play()

        -- Schedule hide
        task.delay(duration or 2, function()
            local tweenOut = TweenService:Create(
                toastFrame,
                TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
                {Position = UDim2.new(0.5, 0, 0, 110)}
            )
            tweenOut:Play()
            tweenOut.Completed:Connect(function()
                toastFrame.Visible = false
            end)
        end)
    end
end

local function updatePanel()
    -- Update scores
    attackScoreLabel.Text = tostring(scores.A or 0)
    defenseScoreLabel.Text = tostring(scores.B or 0)

    -- Update team indicator (removed - now handled by score styling)
    local team = Players.LocalPlayer.Team
    if team then
        local teamColor = team.TeamColor.Color
        -- Team indicator removed - functionality moved to score styling

        -- Highlight active team score with team colors
        if team.Name == "Red" then
            -- Red team: red border and transparent red background for attack score
            attackFrame.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
            attackFrame.BackgroundTransparency = 0.3  -- Transparent red
            attackStroke.Transparency = 0  -- Show red border
            defenseFrame.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
            defenseFrame.BackgroundTransparency = 0.7  -- Default transparency
            defenseStroke.Transparency = 1  -- Hide green border
        elseif team.Name == "Green" then
            -- Green team: green border and transparent green background for defense score
            defenseFrame.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
            defenseFrame.BackgroundTransparency = 0.3  -- Transparent green
            defenseStroke.Transparency = 0  -- Show green border
            attackFrame.BackgroundColor3 = Color3.fromRGB(40, 100, 180)
            attackFrame.BackgroundTransparency = 0.7  -- Default transparency
            attackStroke.Transparency = 1  -- Hide red border
        end
    else
        -- Spectator: reset both frames to default styling
        attackFrame.BackgroundColor3 = Color3.fromRGB(40, 100, 180)
        attackFrame.BackgroundTransparency = 0.7
        attackStroke.Transparency = 1  -- Hide red border
        defenseFrame.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
        defenseFrame.BackgroundTransparency = 0.7
        defenseStroke.Transparency = 1  -- Hide green border
    end

    -- Update timer
    local remain = roundTimeRemaining
    if remain == nil and currentState == "Live" and objectiveStartTime > 0 then
        local elapsed = os.clock() - objectiveStartTime
        remain = math.max(0, objectiveTimeLimit - elapsed)
    end

    if remain then
        timerText.Text = formatTime(remain)
        -- Flash when low time
        if remain &lt;= 10 then
            timerText.TextColor3 = Color3.fromRGB(255, 100, 100)
            timerIcon.TextColor3 = Color3.fromRGB(255, 100, 100)
        else
            timerText.TextColor3 = Color3.fromRGB(255, 255, 255)
            timerIcon.TextColor3 = Color3.fromRGB(180, 180, 180)
        end
    else
        timerText.Text = "--:--"
        timerText.TextColor3 = Color3.fromRGB(180, 180, 180)
        timerIcon.TextColor3 = Color3.fromRGB(150, 150, 150)
    end

    -- Update phase (don't override if already set by message in onRoundChanged)
    local phase = roundPhase or currentState
    if phase == "Lobby" then
        -- Keep existing text if it's a special message, otherwise show default
        if not phaseLabel.Text:find("WAITING") and not phaseLabel.Text:find("STARTING") then
            phaseLabel.Text = "🏠 LOBBY"
            phaseLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        end
    elseif phase == "Live" or phase == "InProgress" then
        phaseLabel.Text = "🎮 LIVE"
        phaseLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
    elseif phase == "Intermission" then
        phaseLabel.Text = "⏸ BREAK"
        phaseLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
    elseif phase == "Prep" then
        phaseLabel.Text = "⏱ GET READY"
        phaseLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
    elseif phase == "End" then
        phaseLabel.Text = "🏆 ROUND OVER"
        phaseLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    elseif phase == "MatchComplete" then
        phaseLabel.Text = "🎯 MATCH COMPLETE"
        phaseLabel.TextColor3 = Color3.fromRGB(255, 200, 50)
    else
        if phase and phase ~= "" then
            phaseLabel.Text = string.upper(phase)
            phaseLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
        end
    end
end

local function onRoundChanged(payload)
    scores = payload and payload.scores or scores
    currentState = payload and payload.state or currentState
    roundTimeRemaining = payload and payload.timeRemaining or nil
    roundPhase = payload and payload.phase or nil

    -- Handle lobby messages
    if payload and payload.message then
        -- Update phase label with the message (e.g., "Waiting for players..." or "Match starting in...")
        phaseLabel.Text = string.upper(payload.message)
        if payload.message:find("Waiting") then
            phaseLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        elseif payload.message:find("starting") then
            phaseLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
        end
    end

    updatePanel()
end

local function onObjectiveEvent(payload)
    if payload.type == "ObjectiveSpawned" then
        objectiveTimeLimit = payload.timeLimit or 60
        objectiveStartTime = os.clock()
        greenSpawnPos = payload.greenSpawn or (workspace:FindFirstChild("GreenSpawn") and workspace.GreenSpawn.Position) or greenSpawnPos
        redSpawnPos = payload.redSpawn or (workspace:FindFirstChild("RedSpawn") and workspace.RedSpawn.Position) or redSpawnPos
        animateToast("🎯 OBJECTIVE SPAWNED", 2, Color3.fromRGB(100, 255, 100))
    elseif payload.type == "ObjectiveDelivered" then
        isCarrier = false
        animateToast("✅ OBJECTIVE DELIVERED", 2.5, Color3.fromRGB(100, 255, 100))
    elseif payload.type == "TimeUp" then
        animateToast("⏰ TIME'S UP", 2, Color3.fromRGB(255, 100, 100))
    elseif payload.type == "Carry" then
        isCarrier = (payload.by == Players.LocalPlayer.UserId)
        if isCarrier then
            local t = Players.LocalPlayer.Team
            if t and t.Name == "Red" then
                animateToast("💎 CARRYING - GO TO RED SPAWN", 3, Color3.fromRGB(255, 220, 50))
            else
                animateToast("💎 CARRYING - AVOID RED TEAM", 3, Color3.fromRGB(255, 220, 50))
            end
        else
            local who = Players:GetPlayerByUserId(payload.by)
            if who and Players.LocalPlayer.Team and who.Team == Players.LocalPlayer.Team then
                animateToast("👥 ALLY HAS OBJECTIVE", 1.5, Color3.fromRGB(100, 200, 255))
            else
                animateToast("⚠️ ENEMY HAS OBJECTIVE", 1.5, Color3.fromRGB(255, 100, 100))
            end
        end
    elseif payload.type == "Dropped" then
        if payload.by == Players.LocalPlayer.UserId then
            isCarrier = false
        end
        animateToast("📦 OBJECTIVE DROPPED", 1.5, Color3.fromRGB(200, 200, 100))
    elseif payload.type == "Stolen" then
        if payload.by == Players.LocalPlayer.UserId then
            isCarrier = true
            animateToast("⚡ STOLEN - RUN!", 2.5, Color3.fromRGB(255, 100, 50))
        elseif payload.from == Players.LocalPlayer.UserId then
            isCarrier = false
            animateToast("❌ STOLEN FROM YOU", 2, Color3.fromRGB(255, 50, 50))
        else
            animateToast("🔄 OBJECTIVE STOLEN", 2, Color3.fromRGB(255, 150, 50))
        end
    end
end

if Events.RoundChanged then Events.RoundChanged.OnClientEvent:Connect(onRoundChanged) end
if Events.Objective then Events.Objective.OnClientEvent:Connect(onObjectiveEvent) end

-- React to team changes
Players.LocalPlayer:GetPropertyChangedSignal("Team"):Connect(updatePanel)

-- Update panel
RunService.RenderStepped:Connect(function()
    updatePanel()
end)</string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <SharedStrings>
    <SharedString md5="rxNJufX5oaagQE3qNtzJSQ=="></SharedString>
  </SharedStrings>
</roblox>